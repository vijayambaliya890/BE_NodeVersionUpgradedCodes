// Controller Code Starts here
const mongoose = require("mongoose")
const StaffSapData = require('../../models/staffSAPData');
const Ballot = require('../../models/ballot');
const OpsGroup = require('../../models/ops');
const OpsTeam = require('../../models/opsTeam');
const User = require('../../models/user');
const PageSettingModel = require('../../models/pageSetting');
const _ = require('lodash');
const __ = require('../../../helpers/globalFunctions');
const CronJob = require('cron').CronJob;
var multiparty = require('multiparty');
const async = require('async');
const moment = require('moment');
const FCM = require('../../../helpers/fcm');
const csv= require('csvtojson');
const swopRequests = require('../../models/swapRequests');
const userHoliday = require('../../models/userHoliday');
const leaveApplications = require('../../models/leaveApplication');
const userLeaves = require('../../models/userLeaves');

class ballot {
    async formatData (data){
        function genrows(groups, groupKey) {
            return _.toPairs(groups)
                .map(([key, data]) => ({[groupKey]: key, data}))
        }

        function gengroups(arr, iteratee, key) {
            const grouped = _.groupBy(arr, iteratee)
            return genrows(grouped, key)
        }

        function grouparray(data, props) {
            let result = [{data}]

            props.map((prop, i) => {
                let k11= '';
                if(i===0){
                    k11 = 'opsGroupId'
                }else {
                    k11 = 'opsTeamId'
                }
                const key = prop.key || k11;
                const iteratee = prop.iteratee || prop

                result = _.flatten(result.map(row => {
                    return gengroups(row.data, iteratee, key)
                        .map(group => Object.assign({}, row, {
                            [key]: group[key],
                            data: group.data
                        }))
                }))

            })

            return _.flatten(result)
        }
        const result =  grouparray(data.data, ['opsG', 'opsT']);
        return result;
    }
    async autoResultRelease(req, res){
        //return res.json('hi');
       
         const staffData = req.body.data;
         const ballotId = req.body.ballotId;
         const userFrom = req.body.userFrom;
         console.log('ballotId', ballotId);
        // const ratio = 2;// req.body.ratio;
         // for OPS group
         const userData = [];
         staffData.forEach((staff)=>{
             delete staff.deepClone;
             userData.push(staff);
         });
         //return res.json({userData})
         if(userFrom ===1) {
             //const result = await this.formatData(data);
             const ballotData = await Ballot.findById({_id: ballotId});
             //return res.json({})
             let reaminSlot = [];
             let slotWiseStaff = [];
             let finalWonStaff = [];
             let totalslotRemain = 0;
             // let resultFilter;
             if (ballotData) {
                 console.log('I amhere 1');
               
                 console.log('I amhere 5', ballotData.isConduct);
                 if(ballotData.isConduct){
                     return res.json({message: 'Already Conduct'});
                 }
                 let parentBallotWon = [];
                 let parentBallotData1;
                 let parentBallotData;
                 let idd;
                 console.log('aaaaaa')
                 for(let ij=0; ij<ballotData.ballotRound; ij++){
                    if(ij == 0){
                       idd=ballotData.parentBallot
                    }else {
                        idd=parentBallotData1.parentBallot
                    }
                    parentBallotData1 = await Ballot.findById({_id: idd});
                    if(ij==0){
                        parentBallotData =   parentBallotData1;
                    }
                    const parentBallotWon1 = JSON.parse(JSON.stringify(parentBallotData1.wonStaff));
                    parentBallotWon = parentBallotWon.concat(parentBallotWon1);
                 }
                 for (let i = 0; i < ballotData.slotCreation.length; i++) {
                     const slotData = ballotData.slotCreation[i];
                     /* // if team present in slot ops group
                      if(slotData.opsTeam && slotData.opsTeam.length>0){
                          slotData.opsTeam.forEach((opsTeamIdF)=>{
                             const resultFilter = result.filter((opt)=>{
                                return opt.opsTeamId == opsTeamIdF._id;
                             });
 
                          });*/
                     let resultFilter = staffData.filter((opt) => {
                         return opt.opsG == slotData.opsGroup.opsId;
                     });
                     if (resultFilter.length > 0) {
                         function shuffle(array) {
                             return array.sort(() => Math.random() - 0.5);
                         }
 
                         resultFilter = shuffle(resultFilter);
 
                         const wonStaffForOpsGroup = ballotData.wonStaff.filter((win) => {
                             return win.opsGroupId == slotData.opsGroup.opsId;
                         });
                         for (let j = 0; j < ballotData.weekRange.length; j++) {
                             let opsGroupQuota = Math.round(parseInt(slotData.weekRangeSlot[j + 'A'].balanceToBeAssigned));
                             const wonStaffList = wonStaffForOpsGroup.filter((win) => {
                                 return win.weekNo == j;
                             });
                             const wonStaffCount = wonStaffList.length;
                             //console.log('wonStaffCount with team', wonStaffCount);
                             // check if team is present or not
                             let totalTeamQuota = -1;
                             let teamStatus = [];
                             if (slotData.opsTeam && slotData.opsTeam.length > 0) {
                                 totalTeamQuota = 0;
                                 teamStatus = [];
                                 slotData.opsTeam.forEach((te, index) => {
                                     let teamQuota = parseInt(slotData.weekRangeSlot['' + j + index].balanceToBeAssigned);
                                     totalTeamQuota += teamQuota;
                                     // get count of staff win this lot for ops team
                                     const winStaffOpsTeam = wonStaffList.filter((ax) => {
                                         return ax.opsTeamId == te._id;
                                     });
                                     const o = {
                                         teamQuota: teamQuota - winStaffOpsTeam.length,
                                         teamWin: winStaffOpsTeam.length,
                                         teamId: te._id,
                                         teamIndex: index
                                     }
                                     teamStatus.push(o);
                                 });
 
                                 totalTeamQuota = Math.round(totalTeamQuota);
                                 let takeQuota = -1;
                                 if (opsGroupQuota < totalTeamQuota) {
                                     takeQuota = opsGroupQuota;
                                 } else {
                                     takeQuota = totalTeamQuota;
                                 }
                                 let slotRemain = takeQuota - wonStaffCount;
                                 totalslotRemain += slotRemain;
                                 const obj = {
                                     weekNo: j,
                                     slotRemain,
                                     teamStatus
                                 };
                                 let slotWonStaff = [];
                                 if (slotRemain > 0) {
                                     const minimum = 0;
                                     const maximum = resultFilter.length - 1;
                                     let howManyTimes = 0;
                                     for (let p = 0; p < slotRemain; p++) {
                                         // get team
                                         const randomNumber = (Math.random() * (maximum - minimum + 1)) << 0;
                                         //console.log(j, 'randmom', randomNumber);
                                         const selectedStaff = resultFilter[randomNumber];
                                         let selectedStaffTeam = teamStatus.filter((ts) => {
                                             return ts.teamId == selectedStaff.opsT
                                         });
                                         selectedStaffTeam = selectedStaffTeam[0];
                                         if(selectedStaff.ballotLeaveBalance > 0 && selectedStaffTeam.teamQuota > 0) {
                                             const isRestirct = await checkStaffRestrict(selectedStaff, parentBallotData, j, finalWonStaff);
                                             // console.log(j,'selectedStaffTeam.teamQuota', selectedStaffTeam.teamQuota);
                                             if (!isRestirct) {
                                                 if (!slotWonStaff.includes(selectedStaff)) {
                                                     slotWonStaff.push(selectedStaff);
                                                     //code by Dipali just needed user name and staffIds
                                                     let st;
                                                     const userData = await User.findOne({_id: selectedStaff.userId}, {
                                                         _id: 0,
                                                         name: 1,
                                                         staffId: 1
                                                     });
                                                     if (!userData) {
                                                         //console.log("staff may have deleted ");
                                                         st = {
                                                             "userId": selectedStaff.userId,
                                                             "weekNo": j,
                                                             "buId": selectedStaff.parentBu,
                                                             "opsGroupId": selectedStaff.opsG,
                                                             "opsTeamId": selectedStaff.opsT,
                                                             isAutoAssign: true
 
                                                         };
                                                     } else {
                                                         st = {
                                                             "userId": selectedStaff.userId,
                                                             "weekNo": j,
                                                             "userData": userData,
                                                             "buId": selectedStaff.parentBu,
                                                             "opsGroupId": selectedStaff.opsG,
                                                             "opsTeamId": selectedStaff.opsT,
                                                             isAutoAssign: true
 
                                                         };
                                                     }
                                                     //till here
                                                     // let st = {
                                                     //     "userId": selectedStaff.userId,
                                                     //     "weekNo": j,
                                                     //     "buId": selectedStaff.parentBu,
                                                     //     "opsGroupId": selectedStaff.opsG,
                                                     //     "opsTeamId": selectedStaff.opsT,
                                                     //     isAutoAssign: true
 
                                                     // };
                                                     finalWonStaff.push(st);
                                                     resultFilter[randomNumber].ballotLeaveBalance = resultFilter[randomNumber].ballotLeaveBalance - 1;
                                                     teamStatus[selectedStaffTeam.teamIndex].teamQuota = teamStatus[selectedStaffTeam.teamIndex].teamQuota - 1;
                                                     howManyTimes = 0;
                                                 } else {
                                                     if (howManyTimes < 5) {
                                                         p = p - 1;
                                                         howManyTimes++;
                                                     }
                                                 }
                                             } else {
                                                 if (howManyTimes < 5) {
                                                     p = p - 1;
                                                     howManyTimes++;
                                                 }
                                             }
                                         } else {
                                             if (howManyTimes < 5) {
                                                 p = p - 1;
                                                 howManyTimes++;
                                             }
                                         }
 
 
                                     }
                                 }
                                 reaminSlot.push(obj);
                             } else {
                                 let slotRemain = opsGroupQuota - wonStaffCount;
                        
                                 const obj = {
                                     weekNo: j,
                                     slotRemain
                                 };
                                 reaminSlot.push(obj);
                                 let slotWonStaff = [];
                                 if (slotRemain > 0) {
                                     const minimum = 0;
                                     const maximum = resultFilter.length - 1;
                                     let howManyTimes = 0;
                                     for (let p = 0; p < slotRemain; p++) {
                                         // get team
                                         const randomNumber = (Math.random() * (maximum - minimum + 1)) << 0;
                                         //console.log(j, 'randmom no team', randomNumber);
                                         const selectedStaff = resultFilter[randomNumber];
                                          if(selectedStaff.ballotLeaveBalance > 0 && opsGroupQuota > 0) {
                                            const isRestirct = await checkStaffRestrict(selectedStaff, parentBallotData, j, finalWonStaff);
                                         //     // console.log(j,'selectedStaffTeam.teamQuota', selectedStaffTeam.teamQuota);
                                            if (!isRestirct) {
                                        // if (selectedStaff.ballotLeaveBalance > 0 && opsGroupQuota > 0 && !selectedStaff.deepClone['' + j + 'A'].isRestrict) {
                                             if (!slotWonStaff.includes(selectedStaff)) {
                                                 slotWonStaff.push(selectedStaff);
                                                 // let st = JSON.parse(JSON.stringify(selectedStaff));
                                                 const userdata=await User.findOne({_id:selectedStaff.userId},{_id:0,name:1,staffId:1});
                                                 let st = {
                                                     "userId": selectedStaff.userId,
                                                     "weekNo": j,
                                                     "buId": selectedStaff.parentBu,
                                                     "opsGroupId": selectedStaff.opsG,
                                                     "opsTeamId": selectedStaff.opsT,
                                                     isAutoAssign: true,
                                                     userData:userdata
 
                                                 };
                                                 finalWonStaff.push(st);
                                                 resultFilter[randomNumber].ballotLeaveBalance = resultFilter[randomNumber].ballotLeaveBalance - 1;
                                                 opsGroupQuota = opsGroupQuota - 1;
                                                 howManyTimes = 0;
                                             } else {
                                                 if (howManyTimes < 5) {
                                                     p = p - 1;
                                                     howManyTimes++;
                                                 }
                                             }
                                         } else {
                                             if (howManyTimes < 5) {
                                                 p = p - 1;
                                                 howManyTimes++;
                                             }
                                         }
                                     }else {
                                         if (howManyTimes < 5) {
                                             p = p - 1;
                                             howManyTimes++;
                                         }
                                     }
                                         
                                        
 
 
                                     }
                                 }
                             }
                             {
                            /*
                            // staff avaiable for auto assgin for this slot
                             // const staffAva = [];
                             // for(let k=0; k<resultFilter.length; k++){
                             //     const staff = resultFilter[k].data;
                             //     const opsGroupId = resultFilter[k].opsGroupId;
                             //     const opsTeamId =  resultFilter[k].opsTeamId;
                             //     // if team
                             //     if (slotData.opsTeam && slotData.opsTeam.length > 0) {
                             //         let teamIndex = -1;
                             //         slotData.opsTeam.forEach((te, index1) => {
                             //             if(opsTeamId === te._id){
                             //                 teamIndex = index1;
                             //             }
                             //         });
                             //         for(let m=0; m<staff.length; m++){
                             //             const staffObj = staff[m];
                             //             // check is staff avaiable
                             //             const staffSlot = staffObj.deepClone[''+j+teamIndex];
                             //             if(!staffSlot.isRestrict){
                             //                 const abc = {
                             //                     opsTeamId,
                             //                     opsGroupId,
                             //                     buId:"",
                             //                     weekNo: j,
                             //                     userId: staffObj.userId
                             //                 };
                             //                 staffAva.push(abc)
                             //             }
                             //         }
                             //     }else {
                             //
                             //     }
                             //
                             // }
                             // slotWiseStaff.push({weekNo:j, staffAva})
                             */
                         }
 
                         }
 
                     }
                 }
                 console.log('qq')
                 const updateWin = await Ballot.findOneAndUpdate({_id: ballotId}, {
                      $set:{isConduct: true, isPublish: true},
                      $push: {
                          wonStaff:{ "$each": finalWonStaff}
                      }
                  });
            
                  const reduceLeave = JSON.parse(JSON.stringify(finalWonStaff));
                  if(reduceLeave.length>0) {
                      let leave = 5;
                      if (ballotData.leaveConfiguration === 2) {
                          leave = 6;
                      } else if (ballotData.leaveConfiguration === 3) {
                          leave = 7;
                      }
                      //console.log('leave', leave);
                      reduceLeave.forEach((item)=>{
                          const sapData = StaffSapData.update({staff_Id: item.userId}, {$inc: {ballotLeaveBalanced: -leave}}).then((result1)=>{
                              //console.log(result1)
                          });
                          // //console.log('sapData', sapData)
                      });
 
                  }
                 finalWonStaff = groupBy(finalWonStaff, 'userId');
 
 
                 function checkStaffRestrict(selectedStaffR, ballotDataR, slotNo, autoWonStaff) {
                     // staff restricted
                   //  console.log('1')
                     let isRestrictedR = false;
                     const userIdR = selectedStaffR.userId.toString();
                     const startDate = ballotDataR.slotCreation[0].arr[slotNo].startDate;
                     let isWinStaff = [];
                     console.log('before ballotDataR.wonStaff',  ballotDataR.wonStaff.length, 'actual won ', parentBallotWon.length, 'auto won ', autoWonStaff.length);
                     if(parentBallotWon && parentBallotWon.length>0){
                     ballotDataR.wonStaff = parentBallotWon.concat(autoWonStaff);
                     }else {
                        ballotDataR.wonStaff = autoWonStaff;
                     }
                     console.log('after ballotDataR.wonStaff',  ballotDataR.wonStaff.length);
                     // start Already Won
                       if(ballotDataR.wonStaff && ballotDataR.wonStaff.length>0){
                         isWinStaff = ballotDataR.wonStaff.filter((win)=>{
                            return (win.userId.toString() === userIdR) && (win.weekNo == slotNo)
                         });
                         if(isWinStaff.length>0){
                             return true;
                         }
                     }
 
                     // end Already Won
 
 
                     // start Staff Restriction for a particular
 
                     if(ballotDataR.staffRestriction && ballotDataR.staffRestriction.length>0){
                         const staffRestrictionResultArr =  ballotDataR.staffRestriction.filter((staffRestriction)=>{
                             return new Date(staffRestriction.startDate).getTime() === new Date(startDate).getTime()
                         });
                         if(staffRestrictionResultArr.length>0){
                             const staffRestrictionResult = staffRestrictionResultArr[0];
                             const userListArr =   staffRestrictionResult.userList.filter((userList)=>{
                                 return userList.id.toString() === userIdR;
                             });
                             if(userListArr.length>0){
                              //   console.log('I am here')
                                 return true;
                             }
                         }
                     }
                    
 
                     // end Staff Restriction for a particular
 
                      // get slot win
                      const slotWinData = ballotDataR.wonStaff.filter((win)=>{
                         return win.userId.toString() === userIdR
                      });
                      const slotWinNo = [];
                      slotWinData.forEach((item)=>{
                         slotWinNo.push(item.weekNo);
                      });
 
                      slotWinNo.push(slotNo);
                      slotWinNo.sort();
                     // console.log('slotWinNo', slotWinNo);
             
                     // maxConsecutiveBallot start
                     const maxConsecutiveBallot = ballotDataR.maxConsecutiveBallot;
                     if(slotWinNo.length>1 && maxConsecutiveBallot){
                        
 
                  
                     let checkMaxCons = 0;
                      let ismaxConsecutiveBallot= false;
                     for(let i=0; i<slotWinNo.length; i++){
                         if(i!==0){
                             let lastValue = slotWinNo[i-1];
                             let currentValue = slotWinNo[i];
                             let diff = currentValue-lastValue;
                             if(diff===1){
                                 checkMaxCons=checkMaxCons+1;
                                 if(checkMaxCons>= maxConsecutiveBallot){
                                     ismaxConsecutiveBallot = true;
                                     break;
                                 }  
                             }else{
                                 checkMaxCons =0;
                             }
                         }
                     }
                     if(ismaxConsecutiveBallot){
                         console.log('is Consuctive')
                         return true;
                     }else {
                         console.log('noottt')
                     }
                     // if(maxConsecutiveBallot){
                     //     const lastSlot = ballotDataR.weekRange.length-1;
                     //     let prevSlot = slotNo - (maxConsecutiveBallot);
                     //     let nextSlot = slotNo + (maxConsecutiveBallot-1);
                     //     // if(prevSlot<0){
                     //     //     prevSlot = 0;
                     //     // }
                     //     // if(nextSlot> lastSlot){
                     //     //     nextSlot = lastSlot
                     //     // }
                     //     const slotCheckArr = [];
                     //     for(let i=0; i<=maxConsecutiveBallot; i++){
                     //         const slotArr = [];
                     //         let isValid = true;
                     //         for(let j=0; j<=maxConsecutiveBallot; j++){
                     //             const slot = prevSlot+j+i;
                     //             if(slot<=-1 || slot> lastSlot){
                     //                 isValid = false;
                     //                 break;
                     //             }
                     //             if(slotNo !== slot){
                     //                 slotArr.push(slot)
                     //             }
                     //         }
                     //         if(isValid) {
                     //             slotCheckArr.push(slotArr)
                     //         }
                     //     }
                     //     console.log(slotNo, 'slotCheckArr', slotCheckArr)
                     //     let isMaxConsiactive = false;
                     //     for(let i=0; i<slotCheckArr.length; i++){
                     //         const checkSlot = slotCheckArr[i];
                     //         let isPresent = true;
                     //         for(let j=0; j< checkSlot.length; j++){
                     //             const checkSlotNo = checkSlot[j];
                     //             const slotPresent = ballotDataR.wonStaff.filter((w)=>{
                     //                return w.userId.toString() === userIdR && w.weekNO === checkSlotNo;
                     //             });
                     //             if(slotPresent.length===0){
                     //                 isPresent = false;
                     //                 break;
                     //             }
                     //         }
                     //         if(isPresent){
                     //             isMaxConsiactive = true;
                     //             break;
                     //         }
                     //     }
                     //     if(isMaxConsiactive){
                     //         return true;
                     //     }
 
                     // }
                 }
                    //  // maxConsecutiveBallot end
 
                     //Segement restriction start;
                     const maxSegement =  ballotDataR.maxSegment;
                     if(maxSegement && maxSegement.length>0){
                         const segmentArr = maxSegement.filter((segement)=>{
                            return new Date(segement.startDate).getTime()<= new Date(startDate).getTime() && new Date(segement.endDate).getTime() >= new Date(startDate).getTime()
                         });
 
                         if(segmentArr.length>0){
                             const segement = segmentArr[0];
                             if(segement.maxBallot) {
                                 const startSlot = ballotDataR.slotCreation[0].arr.findIndex((ss) => {
                                     return new Date(ss.startDate).getTime() === new Date(segement.startDate).getTime();
                                 });
                                 const endSlot = ballotDataR.slotCreation[0].arr.findIndex((ee) => {
                                     let endDate = new Date(ee.startDate);
                                     endDate = endDate.setDate(endDate.getDate() + 6);
                                     //console.log('endDate', new Date(endDate))
                                     return new Date(endDate).getTime() === new Date(segement.endDate).getTime();
                                 });
                                 let slotWon = 0;
                                 console.log('startSlot', slotNo, startSlot, endSlot)
                                 for (let i = startSlot; i <= endSlot; i++) {
                                     const slotWonArr = ballotDataR.wonStaff.filter((ww) => {
                                         return ww.weekNo === i && ww.userId.toString() === userIdR;
                                     });
                                     //console.log('userIdR', userIdR, i, slotWonArr.length);
                                     if (slotWonArr.length > 0) {
                                         slotWon++;
                                     }
                                 }
                                 console.log('slotWon', slotWon, segement.maxBallot)
                                 if(slotWon>=segement.maxBallot){
                                     return true;
                                 }
 
                                 console.log(startSlot, endSlot);
 
                             }else {
                                 return true;
                             }
 
                         }
 
                     }
                     //Segement restriction end;
                         //console.log('last')
                     return false;
                 }
                 function groupBy(xs, key) {
                     return xs.reduce(function (rv, x) {
                         (rv[x[key]] = rv[x[key]] || []).push(x);
                         return rv;
                     }, {});
                 };
 
 
                 return res.json({message: 'Successfully auto assign done', success: true, finalWonStaff})
             } else {
                 return res.json({message: 'Ballot Not found', success: false})
             }
         }else {
             // for BU
             return res.json({message: 'For BU not Implemented', success: false})
         }
     }
    async create(req, res) {
        try {

            // check required filed
            console.log("REQ OBJ : ",req.body);
            req.body.createdBy = req.user._id;
            req.body.companyId = req.user.companyId;
            const data = req.body;
            data.applicationOpenDateTime = moment(data.applicationOpenDateTime, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            data.applicationCloseDateTime = moment(data.applicationCloseDateTime, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            data.ballotStartDate = moment(data.ballotStartDate, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            data.ballotEndDate = moment(data.ballotEndDate, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            if(data.resultRelease === '1') {
                data.resultReleaseDateTime = moment(data.resultReleaseDateTime, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            }
            if(data.isAutoAssign){
                console.log("INSIDE IF");
                new Ballot(data).save().then((ressss)=>{
                    let message = 'Ballot successfully created';
                    if(data.isDraft){
                        message = 'Ballot saved as a draft';
                    }else {
                        //console.log('ressasss', ressss);
                        // notification for publish ballot
                       // this.sendNotification(ressss)
                    }

                    if(data.parentBallot){
                        console.log("Parent Ballot is:",data.parentBallot);
                       this.checkIfHasParentAndUpdate(req.body.parentBallot , ressss._id);
                    }
                  return res.json({status: true, message});
              }).catch((err)=>{
                  console.log('aaaa', err);
              });
            }else{
                console.log("INSIDE ELSE HERE");

                const validationObj = this.validationOfDate(data);
                if (validationObj.status) {
                    let isValidSegmentDate = {status:true,message:''};
                    if (data.maxSegment && data.maxSegment.length > 0 && false) {
                        data.maxSegment.forEach((item) => {
                            item.startDate = moment(item.startDate, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
                            item.endDate = moment(item.endDate, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
                            if(item.startDate === 'Invalid date' ||item.endDate === 'Invalid date'){
                                isValidSegmentDate.status = false;
                                isValidSegmentDate.message = 'Segment Date is not valid';
                            }else if(new Date(item.endDate).getTime() < new Date(item.startDate).getTime()){
                                isValidSegmentDate.status = false;
                                isValidSegmentDate.message = 'Segment start date should be less then end date';
                            }
                            else if(new Date(data.ballotStartDate).getTime() > new Date(item.startDate).getTime() ||
                                new Date(data.ballotEndDate).getTime() < new Date(item.startDate).getTime()){
                                isValidSegmentDate.status = false;
                                isValidSegmentDate.message = 'Segment start date should be between ballot start and end date';
                            }
                            else if(new Date(data.ballotStartDate).getTime() > new Date(item.endDate) ||
                                new Date(data.ballotEndDate).getTime() < new Date(item.endDate)){
                                isValidSegmentDate.status = false;
                                isValidSegmentDate.message = 'Segment end date should be between ballot start and end date';
                            }
                        });
                    }
                    if(isValidSegmentDate.status){
                       /* let isValidstaffRestrictionDate = {status: true, message:''};
                        if (data.staffRestriction && data.staffRestriction.length > 0) {
                            data.staffRestriction.forEach((item) => {
                                item.date = moment(item.date, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
                                if(item.date === 'Invalid date'){
                                    isValidstaffRestrictionDate.status = false;
                                    isValidstaffRestrictionDate.message = 'staff restriction Date is not valid';
                                }
                                else if(new Date(data.ballotStartDate).getTime() > new Date(item.date) ||
                                    new Date(data.ballotEndDate).getTime() < new Date(item.date)){
                                    isValidstaffRestrictionDate.status = false;
                                    isValidstaffRestrictionDate.message = 'staff restriction date should be between ballot start and end date';
                                }
                            });
                        }*/
                            
                             new Ballot(data).save().then((ressss)=>{
                                 let message = 'Ballot successfully created';
                                 if(data.isDraft){
                                     message = 'Ballot saved as a draft';
                                 }else {
                                     //console.log('ressasss', ressss);
                                     // notification for publish ballot
                                    // this.sendNotification(ressss)
                                 }
    
                                 if(data.parentBallot){
                                     console.log("Parent Ballot is:",data.parentBallot);
                                    this.checkIfHasParentAndUpdate(req.body.parentBallot , ressss._id);
                                 }
                               return res.json({status: true, message});
                           }).catch((err)=>{
                               console.log('aaaa', err);
                           });
    
                    }else {
                        return res.json({status: false, message: isValidSegmentDate.message});
                    }
    
    
                } else {
                    return res.json({status: false, message: validationObj.message});
                }
            }
        
        }catch (e) {
            return res.json({status: false, message: 'Something went wrong1', e});
        }

    }

    validationOfDate(data){
        //console.logs("data.applicationOpenDateTime: ",data.applicationOpenDateTime);
        //console.logs("data.applicationCloseDateTime: ",data.applicationCloseDateTime);
        //console.logs("data.ballotStartDate: ",data.ballotStartDate);
        //console.logs("data.resultReleaseDateTime: ",data.resultReleaseDateTime);
        //console.logs("data.ballotEndDate: ",data.ballotEndDate)
        if(data.applicationOpenDateTime === 'Invalid date' || data.applicationCloseDateTime === 'Invalid date'
        || data.ballotStartDate === 'Invalid date' || data.resultReleaseDateTime === 'Invalid date'
            || data.ballotEndDate === 'Invalid date'){
            return {status: false, message: "There are some date are not in valid format"}
        }
        if(data.resultRelease == 1 && new Date(data.applicationCloseDateTime).getTime() > new Date(data.resultReleaseDateTime).getTime()){
            return {status: false, message: 'Result release date should be greater then application close date'};
        }
        if(data.resultRelease == 1 && new Date(data.ballotStartDate).getTime() < new Date(data.resultReleaseDateTime).getTime()){
            return {status: false, message: 'Result release date should be less then ballot start date'};
        }
        if(new Date().getTime()> new Date(data.applicationOpenDateTime).getTime()){
            return {status: false, message: 'Application Open Date should be greater then today'};
        }
        if(new Date(data.applicationCloseDateTime).getTime() < new Date(data.applicationOpenDateTime).getTime()){
            return {status: false, message: 'Application Open Date should be less then close date'};
        }
        if(new Date().getTime()> new Date(data.ballotStartDate).getTime()){
            return {status: false, message: 'Ballot Start Date should be greater then today'};
        }
        if(new Date(data.ballotEndDate).getTime() < new Date(data.ballotStartDate).getTime()){
            return {status: false, message: 'Ballot Start Date should be less then end date'};
        }
        if(new Date(data.applicationOpenDateTime).getTime() > new Date(data.ballotStartDate).getTime()
            || new Date(data.applicationOpenDateTime).getTime() > new Date(data.ballotEndDate).getTime()){
            return {status: false, message: 'Application Open Date should be less then ballot start date or end Date'};
        }
        if(new Date(data.applicationCloseDateTime).getTime() > new Date(data.ballotStartDate).getTime()
            || new Date(data.applicationCloseDateTime).getTime() > new Date(data.ballotEndDate).getTime()){
            return {status: false, message: 'Application Close Date should be less then ballot start date or end Date'};
        }
        return {status:true}
    }
   
    async checkIfHasParentAndUpdate(ballotid,id){
        let currentBallot = await Ballot.findOne({_id:ballotid});
        if(!currentBallot){
            //console.logs("NO ballot found");
        }else{
            //console.logs("in else of current data found");
            if(currentBallot.parentBallot){
                //console.logs("in if of parent data",currentBallot.parentBallot);
                this.checkIfHasParentAndUpdate(currentBallot.parentBallot,id)
            }else{
                //console.logs("in checkIfHasParentAndUpdate update id is: ",id);
                let update = await Ballot.update({_id:currentBallot._id},{$push:{ childBallots : id}});

            }
        }
    }

     async readBallots(req,res){
         try{
            let id = req.user.id;
            //console.logs("id:" ,id);
            let ballots=await Ballot.find({createdBy:id,companyId: req.user.companyId, isDeleted: false})
            .populate([{
                path:'staffRestriction.userList.id',
                select:'name'},
                {
                    path:'adminId',
                    select:'_id name staffId'
                },
                {
                    path:'opsGroupId',model:'OpsGroup',
                    select:'_id opsGroupName'
                }
           ])
            .lean();
           // if(ballots.length>0){
                console.log("IN IF LENGTH:");
                let Ballots = await Ballot.find({adminId:id,companyId: req.user.companyId, isDeleted: false})
                .populate([{
                    path:'staffRestriction.userList.id',
                    select:'name'},
                    {
                        path:'adminId',
                        select:'_id name staffId'
                    },{
                        path:'opsGroupId',model:'OpsGroup',
                        select:'_id opsGroupName'
                    }
               ])
                .lean();
                let dataOf = ballots.concat(Ballots);
                ballots=ballots.concat(Ballots);
                for(let b=0;b<=dataOf.length-1;b++){
                    console.log("inside of for of ballots");
                    if(dataOf[b].childBallots && dataOf[b].childBallots.length>0){
                        console.log("if of childba;;ts ");
                        for(let bb1=0;bb1<=dataOf[b].childBallots.length-1;bb1++){
                            console.log("inside of childballots for",dataOf[b].childBallots[bb1]);
                            let BB = await Ballot.findOne({_id:dataOf[b].childBallots[bb1]})
                            .populate([{
                                path:'staffRestriction.userList.id',
                                select:'name'},
                                {
                                    path:'adminId',
                                    select:'_id name staffId'
                                },{
                                    path:'opsGroupId',model:'OpsGroup',
                                    select:'_id opsGroupName'
                                }
                           ]);
                           if(BB){
                               console.log("HERE mE",BB);
                               let BB1=JSON.stringify(BB);
                               BB1=JSON.parse(BB1);
                               console.log("FOUNF: ",BB1)
                                ballots.push(BB1);
                           }else{
                               console.log("Could not find");
                           }
                        }
                    }else{
                        console.log("NO");
                    }
                }
                console.log("After for",ballots.length);
                var uniq = {};
                var unique = ballots.filter(obj => !uniq[obj._id] && (uniq[obj._id] = true));
                
               // let unique=uniqBy(ballots);
                console.log("UNOQUE DECIDED",unique.length);
                
                return res.json({status: true, data:unique});
            // }else{
            //     let Ballots = await Ballot.find({adminId:id,companyId: req.user.companyId, isDeleted: false})
            //     .populate([{
            //         path:'staffRestriction.userList.id',
            //         select:'name'},
            //         {
            //             path:'adminId',
            //             select:'_id name staffId'
            //         },{
            //             path:'opsGroupId',
            //             select:'_id opsGroupName'
            //         }
            //    ])
            //     .lean();
            //     return res.json({status: true, data:Ballots});
            // }

         }catch(e){
            return res.json({status: false, data: null, message: 'Something went wrong'});
         }

     }

    async read(req, res){
        try {

            const data = await Ballot.find({companyId: req.user.companyId, isDeleted: false})
                .populate([{
                    path:'staffRestriction.userList.id',
                    select:'name'
                }])
                .lean();


            return res.json({status: true, data});
        }catch (e) {
            return res.json({status: false, data: null, message: 'Something went wrong'});
        }
    }
    async readBallotForStaff(req, res){
        try {
                // get ballot for Ops group
                const opsGroupList = await OpsGroup.findOne({userId:req.user._id, isDelete: false}, {_id:1, opsTeamId:1});
                const staffOpsTeam = await OpsTeam.findOne({userId:req.user._id, isDeleted: false, opsGroupId: opsGroupList._id });
                let ballotListOps =[];
                ballotListOps = await Ballot.find({opsGroupId: opsGroupList._id, isPublish: true});
                //console.logs("ballotListOps :",opsGroupList);
                // get ballot for BU
                let ballotListBu = await Ballot.find({businessUnitId: req.user.parentBussinessUnitId, isPublish: true});
                //console.logs('ballotListBu', ballotListBu.length, ballotListOps.length);
                let ballotList = ballotListBu.concat(ballotListOps);
                this.generateBallotDataForStaff(ballotList, res, req,opsGroupList,staffOpsTeam);
                
        }catch (e) {
            return res.status(500).json({
                success:false,
                data:e,
                message:'Something went wrong'
            });
           // return res.json({status: false, data: null, message: 'Something went wrong', e});
        }
    }
    async generateBallotDataForStaff(ballotList, res, req, opsGroupList, opsTeamList){
        if(ballotList.length>0) {
            ballotList = JSON.stringify(ballotList);
            ballotList = JSON.parse(ballotList);
            let userSlot = [];
            let userSlotOps = [];
            let userTierOps=[];
            for (let i = 0; i < ballotList.length; i++) {
                const item = ballotList[i];
                let staffStatus = 'No Application';
                const toBeRemove = [];
               item.appliedStaff.forEach((appliedStaff, index) => {

                    if (req.user._id.toString() === appliedStaff.userId.toString()) {
                        // //console.logs('1')
                        staffStatus = 'Submitted';
                        if(item.isResultRelease) {
                            //staffStatus = "Unsuccessful";
                            appliedStaff.resultStatus = 'Failed';

                            if(item.wonStaff && item.wonStaff.length>0){
                            item.wonStaff.forEach((won)=>{
                               if(req.user._id.toString() === won.userId.toString() && won.weekNo === appliedStaff.weekNo){
                                  // staffStatus = 'Successful';
                                   appliedStaff.resultStatus = 'Successful';
                               }
                            });
                          }
                        }
                    } else {
                        // remove other staff
                        toBeRemove.push(index);
                        //item.appliedStaff.splice(index, 1);
                    }
                });
                if(item.isAutoAssign){
                    if(item.wonStaff && item.wonStaff.length>0){
                        item.wonStaff.forEach((won)=>{
                           if(req.user._id.toString() === won.userId.toString()){
                              // staffStatus = 'Successful';
                               won.resultStatus = 'Successful';
                           }
                           item.appliedStaff.push(won);
                        });
                      }
                }
                delete item.wonStaff;
                for(let iii=toBeRemove.length-1; iii>=0;iii--){
                    item.appliedStaff.splice(toBeRemove[iii], 1);
                }
                ////console.logs('toBeRemove', toBeRemove)
                // if result release
                let ballotStatus = 'Open';
                if (new Date().getTime() > new Date(item.applicationCloseDateTime).getTime()) {
                    ballotStatus = 'Closed';
                }
                if(item.isResultRelease){
                    ballotStatus = 'Closed';
                }
                if(item.isCanceled){
                    ballotStatus = 'Cancelled'
                }
                ballotList[i].staffStatus = staffStatus;
                ballotList[i].ballotStatus = ballotStatus;
                ballotList[i].monthRange = [];
                ////console.logs(JSON.stringify(item.weekRange), 'weekrange');
                ballotList[i].monthRange = JSON.stringify(item.weekRange);
                ballotList[i].monthRange = JSON.parse(ballotList[i].monthRange);

                // week range
                if(ballotList[i].userFrom === 2){
                    ////console.logs('aaaaa', req.user)
                    ////console.logs('req.user.parentBussinessUnitId', req.user._id)
                    userSlot = ballotList[i].slotCreation.filter((bu)=>{
                       // //console.logs('bu.buId', bu.buId)
                        return bu.buId.toString() === req.user.parentBussinessUnitId.toString();
                    });
                   // //console.logs('userSlot', userSlot.length)
                    userSlot = userSlot[0];
                }else {
                    let slotRange = ballotList[i].slotCreation.filter((bu)=>{
                       // //console.logs('bu.buId', opsGroupList._id);
                        return bu.opsGroup.opsId.toString() === opsGroupList._id.toString();
                    });
                    console.log("SLOTRANGE: ",slotRange);
                    slotRange = slotRange[0];
                    userSlotOps = [];
                    userTierOps=[];
                    if(opsGroupList && opsGroupList.opsTeamId.length>0){
                        let teamIndex = slotRange.opsTeam.findIndex((tttt)=>{
                           return tttt._id.toString() === opsTeamList._id.toString();
                        });
                       // //console.logs("TEAMINDEX: ",teamIndex);
                        slotRange.arr.forEach((ii, indexArr)=>{
                            const key = ''+indexArr+teamIndex;
                            const key1 = ''+indexArr+'A';
                           //console.logs("KAY IS:",slotRange.weekRangeSlot[key]);
                           userTierOps.push(slotRange.weekRangeSlot[key1])
                            userSlotOps.push(slotRange.weekRangeSlot[key])
                        });
                    }else {
                        // no team
                        slotRange.arr.forEach((ii, indexArr)=>{
                            const key = ''+indexArr+'A';
                            userSlotOps.push(slotRange.weekRangeSlot[key])
                        });
                    }
                    delete ballotList[i].slotCreation;
                    ballotList[i].slotCreation=[];
                    ballotList[i].slotCreation.push(slotRange);
                }
               // //console.logs("USERLOT:",userSlotOps);
                ballotList[i].monthRange.forEach((dd,index) => {
    
                    dd.month = moment(dd.start).format('MMMM-YY');
                    dd.weekNO = index;
                    if(ballotList[i].userFrom === 2){
                        if(userSlot)
                        dd.quotaValue = userSlot.arr[index].value;
                    }else {
                        
                        ////console.logs("userSlotOps[index].value: ",userSlotOps[index]);
                       if(userTierOps.length>0){
                           dd.tierQuota = userTierOps[index].value;
                       }else{
                        dd.tierQuota = userSlotOps[index].value;
                       }
                        dd.quotaValue = userSlotOps[index].value;
                    }

                });
                ////console.logs(groupBy(ballotList[i].monthRange, 'month'));
                ballotList[i].monthRange = groupBy(ballotList[i].monthRange, 'month');
                const MONTH =[];

               await Object.entries(ballotList[i].monthRange).forEach(entry => {
                    let key = entry[0];
                    let value = entry[1];
                    var objTo={};
                    objTo[key] = value;
                    MONTH.push(objTo);
                    //use key and value here
                  });
                  ballotList[i].monthRange  = MONTH;
                
            }

            function groupBy(xs, key) {
                return xs.reduce(function (rv, x) {
                    (rv[x[key]] = rv[x[key]] || []).push(x);
                    return rv;
                }, {});
            };




              // sort by name
              ballotList.sort(function(a, b) {
                var nameA = a.ballotName.toUpperCase(); // ignore upper and lowercase
                var nameB = b.ballotName.toUpperCase(); // ignore upper and lowercase
                if (nameA < nameB) {
                  return -1;
                }
                if (nameA > nameB) {
                  return 1;
                }

                // names must be equal
                return 0;
              });


            return res.status(201).json({
                success: true,
                data: ballotList

            });
        }else {
            return res.status(400).json({
                success:false,
                data:[],
                message:'No Ballot found'
            });
        }
    }
    async readBallotForStaffApplied(req, res){
        try {
            //console.logs('req.user._id', req.user._id)
           // const ballotList = await Ballot.find({'appliedStaff.userId': req.user._id, isPublish: true}, {slotCreation:0});
           const ballotList = await Ballot.find({$or:[{'appliedStaff.userId': req.user._id},{'wonStaff.userId': req.user._id}], isPublish: true}, {slotCreation:0});

            //console.logs("BALLOTLIST: ",ballotList);
            if(ballotList.length>0) {
                this.generateBallotDataForStaffApplied(ballotList, res, req);
                //return res.json({success: true, ballotList});
                // return res.status(201).json({
                //     success:true,
                //     data:ballotList
                // });
            }
            else {
                return res.status(400).json({
                    success:false,
                    data:e,
                   // error:e,
                    message:'No Ballot applied'
                });
               // return res.json({success: false, message:'No Ballot applied'});
            }


        }catch (e) {
            return res.status(500).json({
                success:false,
                data:e,
                message:'Something went wrong'
            });
           // return res.json({status: false, data: null, message: 'Something went wrong', e});
        }
    }
    async generateBallotDataForStaffApplied(ballotList, res, req){
        let ballotForParent= [];
        //console.logs("ballot list is: ",ballotList);
        if(ballotList.length>0) {
            ballotList = JSON.stringify(ballotList);
            ballotList = JSON.parse(ballotList);
            for (let i = 0; i < ballotList.length; i++) {
                //console.logs("BallotList of i: ",i);
                const item = ballotList[i];
                let staffStatus = 'No Application';
                const toBeRemove = [];
                item.appliedStaff.forEach((appliedStaff, index) => {
                    //console.logs("item.appliedStaff: ", index);
                    if (req.user._id.toString() === appliedStaff.userId.toString()) {
                        //console.logs("AOOLIED CHECK");
                        const slotObj = item.weekRange[appliedStaff.weekNo];
                        //console.logs('slotObj', slotObj);
                        item.appliedStaff[index].slotObj = {};
                        item.appliedStaff[index].slotObj = slotObj;
                        staffStatus = 'Submitted';
                        if (item.isResultRelease) {
                            staffStatus = "Successful";
                            appliedStaff.resultStatus = 'Failed';
                            item.wonStaff.forEach((won) => {
                                if (req.user._id.toString() === won.userId.toString() && won.weekNo === appliedStaff.weekNo) {
                                    staffStatus = 'Successful';
                                    appliedStaff.resultStatus = 'Successful';
                                }
                            });
                        }
                    } else {
                        // remove other staff
                        toBeRemove.push(index);
                        //item.appliedStaff.splice(index, 1);
                    }
                });
                if(item.isAutoAssign){
                    if(item.wonStaff && item.wonStaff.length>0){
                        item.wonStaff.forEach((won)=>{
                            const slotObj = item.weekRange[won.weekNo];
                           if(req.user._id.toString() === won.userId.toString()){
                            won.slotObj = {};
                            won.slotObj = slotObj;
                              // staffStatus = 'Successful';
                               won.resultStatus = 'Successful';
                           }
                           item.appliedStaff.push(won);
                        });
                      }
                }
                delete item.wonStaff;
             

                for (let iii = toBeRemove.length - 1; iii >= 0; iii--) {
                    item.appliedStaff.splice(toBeRemove[iii], 1);
                }
                // if result release
                let ballotStatus = 'Open';
                if (new Date().getTime() > new Date(item.applicationCloseDateTime).getTime()) {
                    ballotStatus = 'Closed';
                }
                if (item.isResultRelease) {
                    ballotStatus = 'Closed';
                }
                ballotList[i].staffStatus = staffStatus;
                ballotList[i].ballotStatus = ballotStatus;

            }
           

            //code added to get won slots for all related ballots

            for (let b = 0; b <= ballotList.length - 1; b++) {
                if (ballotList[b].childBallots && ballotList[b].childBallots.length > 0) {
                    //console.logs("in child ballots list", ballotList[b].childBallots);
                    for (let cb = 0; cb <= ballotList[b].childBallots.length - 1; cb++) {
                        let child = ballotList.find(function (ele) {
                            return ele._id === ballotList[b].childBallots[cb];
                        });
                        //console.logs("Child is: ", child);
                        if (!child) {
                            //console.logs("respetive ballot won may no be there");
                            let BallotChild = await Ballot.findOne({_id: ballotList[b].childBallots[cb]});
                            BallotChild = JSON.stringify(BallotChild);
                            BallotChild = JSON.parse(BallotChild);
                            if (!BallotChild) {
                                //console.logs("NO ballot found so skip it");
                            } else {
                                let parentSuccess = ballotList[b].appliedStaff.filter(function (app) {
                                    return app.resultStatus === 'Successful';
                                });
                                // ballotList[b].appliedStaff=  ballotList[b].appliedStaff.concat(successArray);
                                //console.logs("parentSuccess BAllotchold: ", parentSuccess);
                                BallotChild.appliedStaff = parentSuccess;
                                //console.logs("BAllotchold: ", BallotChild.appliedStaff);
                                ballotForParent.push(BallotChild);
                            }
                        } else {
                            //console.logs("found child yep yep", child.appliedStaff);
                            let parentSuccess = ballotList[b].appliedStaff.filter(function (app) {
                                return app.resultStatus === 'Successful';
                            })
                            let successArray = child.appliedStaff.filter(function (applied) {
                                return applied.resultStatus === 'Successful';
                            });
                            //console.logs("Successfula array is: ", successArray);
                            ballotList[b].appliedStaff = ballotList[b].appliedStaff.concat(successArray);
                            //console.logs(" ballotList[b].childBallots[cb]: ", child)
                            child.appliedStaff = child.appliedStaff.concat(parentSuccess);

                        }
                    }

                } else {
                    //console.logs("no child ballot found");

                }
            }


            ballotList = ballotList.concat(ballotForParent);
            
            return res.status(201).json({
                success: true,
                data: ballotList
            });
        } else {
            return res.status(400).json({
                success: false,
                data: [],
                message: 'No Ballot found'
            });
        }
    }

    async staffApplyForSlot(req, res) {
        try {

            //req.user._id = req.body.userId;
            //console.logs('req.user._id', req.user._id);
            const alreadyApplied = await Ballot.findOne({
                _id: req.body.ballotId, isPublish: true,
                'appliedStaff': {$elemMatch: {weekNo: req.body.slotNumber, userId: req.user._id}}
            });
            ////console.logs('alreadyApplied',alreadyApplied);
            if (!alreadyApplied) {
                let obj = {};
                let checkLeave = await this.checkIsLeavePresent(req.user._id, req.body.leaveConfiguration);
                if (checkLeave) {
                    if (req.body.userFrom === 1) {
                        //console.logs('111');
                        // //console.logs('111',alreadyApplied.userFrom);
                        const opsGroupList = await OpsGroup.findOne({userId: req.user._id, isDelete: false}, {
                            _id: 1,
                            opsTeamId: 1
                        });
                        //  return res.send(opsGroupList)
                        const opsTeamList = await OpsTeam.findOne({userId: req.user._id, isDeleted: false}, {
                            _id: 1,
                            opsGroupId: 1
                        });
                        if (opsTeamList || (opsGroupList && opsGroupList.opsTeamId.length === 0)) {
                            if (opsGroupList.opsTeamId.length === 0) {
                                //console.logs('ygdyug')
                                obj = {
                                    userId: req.user._id,
                                    weekNo: req.body.slotNumber,
                                    buId: req.user.parentBussinessUnitId,
                                    opsGroupId: opsGroupList._id,
                                };
                            } else {

                                obj = {
                                    userId: req.user._id,
                                    weekNo: req.body.slotNumber,
                                    buId: req.user.parentBussinessUnitId,
                                    opsGroupId: opsTeamList.opsGroupId,
                                    opsTeamId: opsTeamList._id
                                };
                            }

                        } else {
                            return res.status(400).json({
                                success: false,
                                message: 'You can not apply for slot as your not in any OPS team'
                            });
                        }

                    } else {
                        obj = {
                            userId: req.user._id,
                            weekNo: req.body.slotNumber,
                            buId: req.user.parentBussinessUnitId
                        };
                    }
                    //console.logs('obj', obj)
                    const apply = await Ballot.findOneAndUpdate({_id: req.body.ballotId},
                        {$push: {"appliedStaff": obj}});
                    let leaveDecrease = 5;
                    if (apply.leaveConfiguration === 2) {
                        leaveDecrease = 6;
                    } else if (apply.leaveConfiguration === 3) {
                        leaveDecrease = 7;
                    }
                    const sapData = await StaffSapData.findOneAndUpdate({staff_Id: req.user._id}, {$inc: {ballotLeaveBalanced: -leaveDecrease}});
                    return res.status(201).json({
                        success: true,
                        message: 'Successfully Applied to slot',
                        sapData
                    });
                } else {
                    return res.status(400).json({
                        success: false,
                        message: 'You do not have leave to apply for slot'
                    });
                }
            } else {
                return res.status(400).json({
                    success: false,
                    message: 'You are already applied for same slot'
                });
            }


        } catch (e) {
            return res.status(500).json({status: false, data: null, message: 'Something went wrong', e});
        }
    }

    async staffApplyForSlotMulti(req, res) {
        //  try {

        //req.user._id = req.body.userId;
        //console.logs('req.user._id', req.user._id);
        const alreadyArr = [];
        const successArr = [];
        const failedArr = [];
        for (let i = 0; i < req.body.slotNumber.length; i++) {
            const slotNumber = req.body.slotNumber[i];
            const alreadyApplied = await Ballot.findOne({
                _id: req.body.ballotId, isPublish: true,
                'appliedStaff': {$elemMatch: {weekNo: slotNumber, userId: req.user._id}}
            });
            ////console.logs('alreadyApplied',alreadyApplied);
            if (!alreadyApplied) {
                let obj = {};
                let checkLeave = await this.checkIsLeavePresent(req.user._id, req.body.leaveConfiguration);
                if (checkLeave) {
                    if (req.body.userFrom === 1) {
                        //console.logs('111');
                        // //console.logs('111',alreadyApplied.userFrom);
                        const opsGroupList = await OpsGroup.findOne({userId: req.user._id, isDelete: false}, {
                            _id: 1,
                            opsTeamId: 1
                        });
                        //  return res.send(opsGroupList)
                        const opsTeamList = await OpsTeam.findOne({userId: req.user._id, isDeleted: false}, {
                            _id: 1,
                            opsGroupId: 1
                        });
                        if (opsTeamList || (opsGroupList && opsGroupList.opsTeamId.length === 0)) {
                            if (opsGroupList.opsTeamId.length === 0) {
                                //console.logs('ygdyug')
                                obj = {
                                    userId: req.user._id,
                                    weekNo: slotNumber,
                                    buId: req.user.parentBussinessUnitId,
                                    opsGroupId: opsGroupList._id,
                                };
                            } else {

                                obj = {
                                    userId: req.user._id,
                                    weekNo: slotNumber,
                                    buId: req.user.parentBussinessUnitId,
                                    opsGroupId: opsTeamList.opsGroupId,
                                    opsTeamId: opsTeamList._id
                                };
                            }

                        } else {
                            failedArr.push(slotNumber);
                            /* return res.status(400).json({
                                 success: false,
                                 message: 'You can not apply for slot as your not in any OPS team'
                             });*/
                        }

                    } else {
                        obj = {
                            userId: req.user._id,
                            weekNo: slotNumber,
                            buId: req.user.parentBussinessUnitId
                        };
                    }
                    // //console.logs('obj', obj)
                    const apply = await Ballot.findOneAndUpdate({_id: req.body.ballotId},
                        {$push: {"appliedStaff": obj}});
                    let leaveDecrease = 5;
                    if (apply.leaveConfiguration === 2) {
                        leaveDecrease = 6;
                    } else if (apply.leaveConfiguration === 3) {
                        leaveDecrease = 7;
                    }
                    const sapData = await StaffSapData.findOneAndUpdate({staff_Id: req.user._id}, {$inc: {ballotLeaveBalanced: -leaveDecrease}});
                    successArr.push(slotNumber);
                    /*return res.status(201).json({
                        success: true,
                        message: 'Successfully Applied to slot',
                        sapData
                    });*/
                } else {
                    failedArr.push(slotNumber);
                    // return res.status(400).json({
                    //     success: false,
                    //     successArr,
                    //     alreadyArr,
                    //     failedArr,
                    //     message: 'You do not have leave to apply for slot'
                    // });
                    // break;
                }
            } else {
                alreadyArr.push(slotNumber);
                /*return res.status(400).json({
                    success: false,
                    message: 'You are already applied for same slot'
                });*/
            }
        }
        return res.status(201).json({
            success: true,
            message: 'Successfully Applied to slot',
            successArr,
            alreadyArr,
            failedArr
        });

        // }catch (e) {
        //     return res.status(500).json({status: false, data: null, message: 'Something went wrong', e});
        // }
    }

    async staffApplyForMultipleSlots(req, res) {
        let data = req.body;
        let failedArr = [];
        let successArr = [];
        const alreadyApplied = await Ballot.findOne({_id: data.ballotId, isPublish: true});
        // //console.logs("Already apply are: ",alreadyApplied);
        //  req.user._id = "5a9973ae36ab4f444b42718b"
        for (var j = 0; j <= alreadyApplied.appliedStaff.length - 1; j++) {
            if (req.user._id.toString() === alreadyApplied.appliedStaff[j].userId.toString()) {
                let leaveIncrease = 5;
                if (alreadyApplied.leaveConfiguration === 2) {
                    leaveIncrease = 6;
                } else if (alreadyApplied.leaveConfiguration === 3) {
                    leaveIncrease = 7;
                }

                const sapData = await StaffSapData.findOneAndUpdate({staff_Id: req.user._id}, {$inc: {ballotLeaveBalanced: leaveIncrease}});

            } else {
                //console.logs("Not similar one");
            }
        }
        const pullStaff = await Ballot.update({_id: data.ballotId, 'appliedStaff.userId': req.user._id,},
            {$pull: {appliedStaff: {userId: req.user._id}}});

        //console.logs("req.body.leaveConfiguration :", req.body.leaveConfiguration);

        for (let i = 0; i < req.body.slotNumber.length; i++) {
            let obj = {};
            const slotNumber = req.body.slotNumber[i];
            let checkLeave = await this.checkIsLeavePresentMultiple(req.user._id, req.body.leaveConfiguration);
            //console.logs("checkleave", checkLeave);
            if (checkLeave) {
                if (req.body.userFrom === 1) {
                    //console.logs('111');
                    // //console.logs('111',alreadyApplied.userFrom);
                    const opsGroupList = await OpsGroup.findOne({userId: req.user._id, isDelete: false}, {
                        _id: 1,
                        opsTeamId: 1
                    });
                    //  return res.send(opsGroupList)
                    const opsTeamList = await OpsTeam.findOne({userId: req.user._id, isDeleted: false}, {
                        _id: 1,
                        opsGroupId: 1
                    });
                    if (opsTeamList || (opsGroupList && opsGroupList.opsTeamId.length === 0)) {
                        if (opsGroupList.opsTeamId.length === 0) {
                            //console.logs('ygdyug')
                            obj = {
                                userId: req.user._id,
                                weekNo: slotNumber,
                                buId: req.user.parentBussinessUnitId,
                                opsGroupId: opsGroupList._id,
                            };
                        } else {

                            obj = {
                                userId: req.user._id,
                                weekNo: slotNumber,
                                buId: req.user.parentBussinessUnitId,
                                opsGroupId: opsTeamList.opsGroupId,
                                opsTeamId: opsTeamList._id
                            };
                        }

                    } else {
                        //console.logs("OPS AND OPS TEAM FAILED");
                        failedArr.push(slotNumber);
                        /* return res.status(400).json({
                             success: false,
                             message: 'You can not apply for slot as your not in any OPS team'
                         });*/
                    }

                } else {
                    obj = {
                        userId: req.user._id,
                        weekNo: slotNumber,
                        buId: req.user.parentBussinessUnitId
                    };
                }
                // //console.logs('obj', obj)
                const apply = await Ballot.findOneAndUpdate({_id: req.body.ballotId},
                    {$push: {"appliedStaff": obj}});
                let leaveDecrease = 5;
                if (apply.leaveConfiguration === 2) {
                    leaveDecrease = 6;
                } else if (apply.leaveConfiguration === 3) {
                    leaveDecrease = 7;
                }
                const sapData = await StaffSapData.findOneAndUpdate({staff_Id: req.user._id}, {$inc: {ballotLeaveBalanced: -leaveDecrease}});
                successArr.push(slotNumber);
                /*return res.status(201).json({
                    success: true,
                    message: 'Successfully Applied to slot',
                    sapData
                });*/
            } else {
                //console.logs("CHECK LEAVE FAILED");
                failedArr.push(slotNumber);
                // return res.status(400).json({
                //     success: false,
                //     successArr,
                //     alreadyArr,
                //     failedArr,
                //     message: 'You do not have leave to apply for slot'
                // });
                // break;
            }
        }
        return res.status(201).json({
            success: true,
            message: 'Successfully Applied.',
            successArr,
            failedArr
        });

    }

    async checkIsLeavePresentMultiple(id, leave) {
        //console.logs("LEAVE IN MUL:", leave);
        let howMany = 7;
        if (leave === 1) {
            howMany = 5;
        } else if (leave === 2) {
            howMany = 6;
        }

        let staffLeave = await StaffSapData.findOne({staff_Id: id});
        //  //console.logs('staffLeave',staffLeave);
        return (staffLeave && !(howMany > staffLeave.ballotLeaveBalanced));

    }

    async checkIsLeavePresent(id, leave) {
        let howMany = 7;
        if (leave === 1) {
            howMany = 5;
        } else if (leave === 2) {
            howMany = 6;
        }

        let staffLeave = await StaffSapData.findOne({staff_Id: id});
        //console.logs('staffLeave', staffLeave);
        return (staffLeave && howMany <= staffLeave.ballotLeaveBalanced);

    }

    async sapDataImport(req, res) {
        const bodyData = await this.parseBodyData(req);
        if (bodyData && bodyData.staffDetails && bodyData.staffDetails.length > 0) {
            const csvLength = bodyData.staffDetails.length;
            //console.logs('bof', bodyData);
            // return res.json({bodyData})
            // BU logic remain
            let asyncIndex = 0;
            let failedStaff = [];
            let successStaff = [];
            await async.eachSeries(
                bodyData.staffDetails, (item, next) => {
                    User.findOne({staffId: item['Staff ID']}, {
                        _id: 1,
                        appointmentId: 1,
                        role: 1,
                        subSkillSets: 1,
                        parentBussinessUnitId: 1
                    }).then((userInfo) => {
                        //console.logs(asyncIndex)
                        if (userInfo) {
                            bodyData.staffDetails[asyncIndex].staff_Id = userInfo._id;
                            bodyData.staffDetails[asyncIndex].staffAppointmentId = userInfo.appointmentId;
                            bodyData.staffDetails[asyncIndex].staffRoleId = userInfo.role;
                            bodyData.staffDetails[asyncIndex].businessUnitId = userInfo.parentBussinessUnitId;
                            bodyData.staffDetails[asyncIndex].plannedBy = req.user._id;
                            bodyData.staffDetails[asyncIndex].subSkillSets = userInfo.subSkillSets;
                            bodyData.staffDetails[asyncIndex].leavesEntitled = item['Leaves entitled'];
                            bodyData.staffDetails[asyncIndex].leavesAvailed = item['Leaves availed'];
                            bodyData.staffDetails[asyncIndex].leavesBalanced = item['Leave balance'];
                            bodyData.staffDetails[asyncIndex].ballotLeaveBalanced = item['Leave balance'];
                            asyncIndex++;
                            if (asyncIndex === csvLength) {
                                this.sendResponse(bodyData.staffDetails, res, failedStaff, req)
                            }
                            next();
                        } else {
                            item.faildMessage = 'Staff not found';
                            item.status = 0;
                            failedStaff.push(item);
                            bodyData.staffDetails[asyncIndex] = null;
                            //bodyData.staffDetails.splice(asyncIndex, 1);
                            asyncIndex++;
                            if (asyncIndex === csvLength) {
                                this.sendResponse(bodyData.staffDetails, res, failedStaff, req);
                            }
                            next();
                        }
                    }).catch((err) => {
                        //console.logs('err', err)
                        item.faildMessage = 'Error';
                        item.status = 0;
                        failedStaff.push(item);
                        bodyData.staffDetails[asyncIndex] = null;
                        // bodyData.staffDetails.splice(asyncIndex, 1);
                        asyncIndex++;
                        if (asyncIndex === csvLength) {
                            this.sendResponse(bodyData.staffDetails, res, failedStaff, req)
                        }
                        next();
                    });

                });
            ////console.logs('c');
        } else {
            return res.json({status: false, code: 1, message: 'There is problem in CSV file'});
        }
    }

    async sendResponse(data, res, failed, req) {
        try {
            //console.logs('data', data)
            const dataLength = data.length;
            for (let i = 0; i < dataLength; i++) {
                let item = data[i];
                //  //console.logs('i,i', item);
                if (item) {
                    //  //console.logs('i', i)
                    const result = await StaffSapData.findOne({staff_Id: item.staff_Id});
                    // //console.logs('result', result)
                    if (!result) {
                        //console.logs('not found')
                        await new StaffSapData(item).save();
                    } else {
                        // //console.logs('i', i)
                        const increaseLeave = result.leavesBalanced + parseInt(item.leavesBalanced);
                        const ballotLeaveBalanced = result.ballotLeaveBalanced + parseInt(item.leavesBalanced);
                        const newResult = await StaffSapData.findOneAndUpdate({staff_Id: item.staff_Id}, {
                            $set: {
                                leavesAvailed: item.leavesAvailed,
                                // leavesBalanced: item.leavesBalanced,
                                leavesBalanced: increaseLeave,
                                leavesEntitled: item.leavesEntitled,
                                ballotLeaveBalanced: ballotLeaveBalanced
                            }
                        })
                        ////console.logs(item);
                    }
                }

            }
            //console.logs('i', 4);
            return res.json({status: true, message: "Data Successfully imported"});
        } catch (e) {
            return res.json({status: false, message: "Data Not Successfully imported", e});
        }
    }

    parseBodyData(req) {
        return new Promise((resolve, reject) => {
            var form = new multiparty.Form();
            form.parse(req, function (err, fields, files) {
                //console.logs("FILES:", files);
                const pathCSV = files.ff[0].path;
                csv()
                    .fromFile(pathCSV)
                    .then((jsonObj) => {
                        const dataRequiredObj = {
                            staffDetails: jsonObj
                        };
                        resolve(dataRequiredObj);
                    }).catch((err) => {
                    reject(null);
                });
            });
        });
    }

    async staffCancelSlot(req, res) {
        try {
            const data = req.body;
            //console.logs('re', req.user._id);
            const ballotData = await Ballot.findOne({
                _id: data.ballotId, 'appliedStaff.userId': req.user._id,
                'appliedStaff.weekNo': data.slotNumber
            });

            if (ballotData) {
                if (new Date(ballotData.applicationCloseDateTime).getTime() > new Date().getTime()) {
                    const pullStaff = await Ballot.update({
                        _id: data.ballotId, 'appliedStaff.userId': req.user._id,
                        'appliedStaff.weekNo': data.slotNumber
                    }, {$pull: {appliedStaff: {userId: req.user._id, weekNo: data.slotNumber}}});

                    const pushStaff = await Ballot.update({_id: data.ballotId}, {
                        $push: {
                            deletedStaff: {
                                userId: req.user._id,
                                weekNo: data.slotNumber
                            }
                        }
                    });
                    if (pullStaff.nModified > 0) {
                        let leave = 5;
                        if (ballotData.leaveConfiguration === 2) {
                            leave = 6;
                        } else if (ballotData.leaveConfiguration === 3) {
                            leave = 7;
                        }
                        const updateLeave = await StaffSapData.update({staff_Id: req.user._id}, {$inc: {ballotLeaveBalanced: leave}});
                    }

                    return res.status(201).json({success: true, message: 'Successfully Canceled'});
                }
                return res.status(400).json({success: false, message: 'Can not Cancel slot as ballot is closed'});
            } else {
                return res.status(400).json({success: false, message: 'Ballot Not found'});
            }
        } catch (e) {
            return res.status(500).json({success: false, message: 'Something went wrong'});
        }
    }

    async annualLeave(req, res) {
        try {
            console.log("I am gere",req.user._id);
            const annualData = await StaffSapData.findOne({staff_Id: req.user._id});
            console.log("Annual : ",annualData);
            if(annualData === null){
                let data ={
                    postBallotBalance: 0,
                    daysBallotApplied:0,
                     ballotLeaveBalanced:0,
                    leavesBalanced : 0,
                     leavesAvailed : 0,
                     leavesEntitled : 0,
                }
                return res.status(201).json({
                    success: true,
                    data: data
                });
            }
            else{
                
                return res.status(201).json({
                    success: true,
                    data: annualData
                });
            }
            
            //return res.json({status: true, data: annualData});
        } catch (e) {
            return res.status(400).json({
                success: false,
                data: e,
                // error:e,
                message: 'Something went wrong'
            });
            //return res.json({status: false, data: null, message:'Something went wrong', e})
        }
    }

    async userList(req, res) {
        try {
            //console.logs('req.body', req.body);
            if (req.body.isOpsGroup) {
                if (req.body.opsGroupId && req.body.opsGroupId.length > 0) {
                    let opsGroupInfo = await OpsGroup.find({_id: {"$in": req.body.opsGroupId}})
                        .select('opsTeamId userId buId opsGroupName')
                        .populate([{
                            path: 'opsTeamId',
                            select: 'name userId buId'
                        }, {
                            path: 'userId',
                            select: '_id parentBussinessUnitId name staffId'
                        }
                        ])
                        .lean();
                    //console.logs('opsGroupInfo', opsGroupInfo)
                    opsGroupInfo = JSON.stringify(opsGroupInfo);
                    opsGroupInfo = JSON.parse(opsGroupInfo);
                    const userInfo = [];
                    for (let i = 0; i < opsGroupInfo.length; i++) {
                        const opsItem = opsGroupInfo[i];
                        opsItem.opsTeamId.forEach((teamItem) => {
                            teamItem.userId.forEach((userItem) => {
                                opsItem.userId.forEach((opsGroupUser, index) => {
                                    //console.logs(opsGroupUser, userItem)
                                    if (opsGroupUser._id == userItem) {
                                        opsGroupInfo[i].userId[index].opsTeam = teamItem.name;
                                        opsGroupInfo[i].userId[index].opsTeamId1 = teamItem._id;

                                    }
                                    opsGroupInfo[i].userId[index].opsGroupName = opsGroupInfo[i].opsGroupName;
                                    opsGroupInfo[i].userId[index].opsGroupId = opsGroupInfo[i]._id;

                                });
                            });
                        });

                        opsItem.userId.forEach((opsGroupUser, index) => {
                            opsGroupInfo[i].userId[index].opsGroupName = opsGroupInfo[i].opsGroupName;
                            opsGroupInfo[i].userId[index].opsGroupId = opsGroupInfo[i]._id;
                            userInfo.push(opsGroupInfo[i].userId[index]);
                        });
                    }
                    return res.status(201).json({
                        success: true,
                        data: userInfo
                    });
                    // return res.json({status: true, data: userInfo});
                } else {
                    return res.status(400).json({
                        success: false,
                        data: e,
                        message: 'Please send Ops Group Id'
                    });
                    // return res.json({status: false, data: null, message: 'Please send Ops Group Id'});
                }
            } else {
                if (req.body.buId && req.body.buId.length > 0) {
                    const userInfo = await User.find({parentBussinessUnitId: {$in: req.body.buId}, status: 1})
                        .select('_id parentBussinessUnitId name staffId')
                        .populate([
                            {
                                path: 'parentBussinessUnitId',
                                select: 'sectionId name',
                                populate: {
                                    path: 'sectionId',
                                    select: 'name departmentId adminEmail techEmail shiftCancelHours cancelShiftPermission standByShiftPermission status',
                                    populate: {
                                        path: 'departmentId',
                                        select: 'name status companyId',
                                        populate: {
                                            path: 'companyId',
                                            select: 'name'
                                        }
                                    }
                                }
                            }
                        ]).lean();
                    return res.status(201).json({
                        success: true,
                        data: userInfo
                    });
                    //return res.json({status: true, data: userInfo});
                } else {
                    return res.status(400).json({
                        success: false,
                        data: e,
                        message: 'Please send BUId'
                    });
                    // return res.json({status: false, data: null, message: 'Please send BUId'});
                }

            }

        } catch (e) {
            return res.status(500).json({
                success: false,
                data: e,
                message: 'Something went wrong'
            });
            // return res.json({status: false, data: null, message:'Something went wrong', e})
        }
    }

    async run(req, res) {
        // find ballot
        // get userID weekwise applied
        //
    }

    async delete(req, res) {
        try {
            // const id = req.params.id;
            //const data = req.body;
            //  //console.logs('daataaaa', data)
            if (req.body.isDeleted) {
                const data = await Ballot.update({_id: req.body.id}, {companyId: req.user.companyId, isDeleted: true})
                return res.json({success: true, message: 'Ballot deleted successfully'});
            } else {
                const data = await Ballot.update({_id: req.body.id}, {companyId: req.user.companyId, isCanceled: true})
                return res.json({success: true, message: 'Ballot canceled successfully'});
            }
        } catch (e) {
            return res.json({success: false, message: 'Something went wrong'});
        }
    }

    async update(req, res) {
        try {
            //console.logs("in update");
            const id = req.body.id;
            delete req.body.id;
            //console.logs('req.body.id', req.body)
            const data = await Ballot.findOneAndUpdate({_id: id}, req.body);
            sendBallotEditNotification(data);
            return res.json({success: true, message: 'Ballot Updated successfully'});
        } catch (e) {
            return res.json({success: false, message: 'Something went wrong'});
        }
    }

    async getballotAdmins(req, res) {

        try {
            let adminsList = await User.find({parentBussinessUnitId: req.user.parentBussinessUnitId}, {
                name: 1,
                status: 1
            });
            if (adminsList) {

                return res.json({status: true, data: adminsList});
            } else {
                return res.json({status: false, data: "no admin found"});
            }
        } catch (e) {
            return res.json({status: false, data: null, message: 'Something went wrong', e})
        }


    }

    async leaveBallotSetting(req, res) {
        try {

            let pageSettingData = await PageSettingModel.findOne({
                companyId: req.user.companyId,
                status: 1
            }).select('opsGroup').lean();


            if (!pageSettingData) {

            }

            return __.out(res, 201, pageSettingData);

        } catch (err) {
            __.log(err);
            return __.out(res, 500);
        }
    }

    async winBallotForStaff(req, res) {
        try {
            const ballotId = req.params.id;
            //console.logs('ballotId', ballotId)
            let ballotResult = await Ballot.findOne({_id: ballotId, isPublish: true});
            if (ballotResult) {
                // result for BU
                if (ballotResult.userFrom === 2) {
                    ballotResult = JSON.stringify(ballotResult);
                    ballotResult = JSON.parse(ballotResult);
                    ////console.logs('ballotResult', ballotResult);
                    let shuffle = [];
                    shuffle = ballotResult.slotCreation;
                    ballotResult.appliedStaff.forEach((appliedStaff) => {
                        const indexOfBu = ballotResult.slotCreation.findIndex(x => x.buId === appliedStaff.buId);
                        if (shuffle[indexOfBu].arr[appliedStaff.weekNo].appliedStaff) {
                            shuffle[indexOfBu].arr[appliedStaff.weekNo].appliedStaff.push(appliedStaff);
                        } else {
                            shuffle[indexOfBu].arr[appliedStaff.weekNo].appliedStaff = [];
                            shuffle[indexOfBu].arr[appliedStaff.weekNo].appliedStaff.push(appliedStaff);
                        }

                    });
                    let finalWinStaff = [];
                    shuffle.forEach((staffShuffle) => {
                        staffShuffle.arr.forEach((slotWise) => {
                            const howMuchWin = slotWise.value;

                            if (slotWise.appliedStaff && slotWise.appliedStaff.length <= howMuchWin) {
                                finalWinStaff = finalWinStaff.concat(slotWise.appliedStaff);
                            } else if (slotWise.appliedStaff) {
                                const randomStaff = this.getRandomNumber(slotWise.appliedStaff.length, howMuchWin);
                                randomStaff.forEach((randomSelectedStaff) => {
                                    finalWinStaff.push(slotWise.appliedStaff[randomSelectedStaff])
                                });
                                //console.logs('slotWise.appliedStaff.length', slotWise.appliedStaff.length, howMuchWin, randomStaff)
                            }
                        });
                    });
                    const updateWin = await Ballot.findOneAndUpdate({_id: ballotId}, {
                        $set: {
                            wonStaff: finalWinStaff,
                            isResultRelease: true
                        }
                    });
                    this.unSuccessfullStaffLeaveBallotBalanaceUpdate(ballotId);
                    return res.status(200).json({
                        success: true,
                        message: 'Result release successfully',
                        finalWinStaff
                    });
                } else {
                    // for ops group
                    ballotResult = JSON.stringify(ballotResult);
                    ballotResult = JSON.parse(ballotResult);
                    ////console.logs('ballotResult', ballotResult);
                    let shuffle = [];

                    const opsGroupQuota = [];
                    shuffle = ballotResult.slotCreation;
                    let appliedStaffArray = [];
                    for (let i = 0; i < ballotResult.slotCreation.length; i++) {

                        const opsGroupSlot = ballotResult.slotCreation[i];
                        // get quato for ops group
                        // get quato for team
                        let slotValue = {
                            opsGroupId: opsGroupSlot.opsGroup.opsId,
                            slotQuota: []
                        };
                        opsGroupSlot.arr.forEach((arrItem, arrIndex) => {
                            ////console.logs('aaaaaaaa');
                            let key = '' + arrIndex + 'A';
                            let slotNumber = arrIndex;
                            let slotOpsGroupValue = parseInt(opsGroupSlot.weekRangeSlot[key].value);
                            //opsGroupQuato.push({value:opsGroupSlot.weekRangeSlot[key].value, key});
                            const teamValue = [];
                            let totalTeamQuota = 0;
                            opsGroupSlot.opsTeam.forEach((teamItem, teamIndex) => {
                                ////console.logs('aaaaaaaa');
                                let key = '' + arrIndex + teamIndex;
                                totalTeamQuota = totalTeamQuota +parseInt(opsGroupSlot.weekRangeSlot[key].value);
                                teamValue.push(parseInt(opsGroupSlot.weekRangeSlot[key].value))

                            });
                            const obj = {
                                slot: slotNumber,
                                opsGroupQuotaValue: slotOpsGroupValue,
                                opsTeamQuotaValue: teamValue,
                                totalTeamQuota
                            };
                            slotValue.slotQuota.push(obj);
                        });
                        ////console.logs('aauued', slotValue)
                        opsGroupQuota.push(slotValue)
                        ////console.logs('yyegwb');
                        ////console.logs('aaaa', groupBy(ballotResult.appliedStaff,'weekNo'));
                        let appliedStaffObject = {};
                        appliedStaffObject = groupBy(ballotResult.appliedStaff, 'opsTeamId');
                        ////console.logs('appliedStaffObject', appliedStaffObject)
                        //return res.send(ballotResult.appliedStaff)
                        /* for(let keyyy in appliedStaffObject){
                             const ayaya = groupBy(appliedStaffObject[keyyy],'weekNo');
                             appliedStaffArray.push(ayaya);
                         }*/
                        const opsGroupSlotWithTeam = {
                            opsGroupId: opsGroupSlot.opsGroup.opsId,
                            opsTeamValue: []
                        };
                        //console.logs('yyegwbaaa');
                        if (opsGroupSlot.opsTeam && opsGroupSlot.opsTeam.length > 0) {
                            opsGroupSlot.opsTeam.forEach((teamItem, teamIndex) => {
                                if (appliedStaffObject[teamItem._id]) {
                                    const ayaya = groupBy(appliedStaffObject[teamItem._id], 'weekNo');
                                    opsGroupSlotWithTeam.opsTeamValue.push(ayaya);
                                }

                            });
                        } else {
                            //console.logs('no temmmm');
                            const ayaya = groupBy(appliedStaffObject['undefined'], 'weekNo');
                            opsGroupSlotWithTeam.opsTeamValue.push(ayaya);
                        }
                        ////console.logs('hgfgetgt')
                        appliedStaffArray.push(opsGroupSlotWithTeam);
                        /*groupBy(ballotResult.appliedStaff, function(item)
                        {
                            return [item.weekNo, item.opsTeamId];
                        });*/

                    }

                    ////console.logs('aaaaaaaa');
                    function groupBy(xs, key) {
                        return xs.reduce(function (rv, x) {
                            (rv[x[key]] = rv[x[key]] || []).push(x);
                            return rv;
                        }, {});
                    };
                    /* function groupBy( array , f )
                     {
                         var groups = {};
                         array.forEach( function( o )
                         {
                             var group = JSON.stringify( f(o) );
                             groups[group] = groups[group] || [];
                             groups[group].push( o );
                         });
                         return Object.keys(groups).map( function( group )
                         {
                             return groups[group];
                         })
                     }*/

                    let limitQuota = [];
                    let finalWinStaff = [];
                    ////console.logs('aaaaaaaa');
                    opsGroupQuota.forEach((item, topIndex) => {
                        ////console.logs('aaa')
                        let objA = {
                            opsGroupId: item.opsGroupId,
                        };
                        item.slotQuota.forEach((slll) => {
                            objA.slot = slll.slot;
                            if (slll.opsTeamQuotaValue.length === 0) {
                                objA.isTeamPresent = false;
                                objA.opsGroupQuotaValue = slll.opsGroupQuotaValue;
                                // //console.logs('callleddd');
                                if (appliedStaffArray[topIndex].opsTeamValue[0] && appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot]) {
                                    if (slll.opsGroupQuotaValue >= appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot].length) {
                                        finalWinStaff = finalWinStaff.concat(appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot])

                                    } else {
                                        const randomStaff = this.getRandomNumber(appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot].length, slll.opsGroupQuotaValue);
                                        randomStaff.forEach((ppp) => {
                                            finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot][ppp])
                                        });
                                    }
                                }

                                // const randomStaff = this.getRandomNumber(slotWise.appliedStaff.length, howMuchWin);
                            } else if (slll.opsGroupQuotaValue >= slll.totalTeamQuota) {
                                // all team quota should win
                                slll.opsTeamQuotaValue.forEach((p, opsTeamQuotaValueIndex) => {

                                    if (appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex] && appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot]) {
                                        //console.logs('bbb');
                                        const len = appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot].length;
                                        //console.logs('len', len, slll.slot, p);
                                        // p means no of win
                                        // len means no of applied
                                        if (len > p) {
                                            const randomStaff = this.getRandomNumber(len, p);
                                            //console.logs('randomStaff', randomStaff);
                                            randomStaff.forEach((randomSelectedStaff) => {
                                                finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot][randomSelectedStaff])
                                            });
                                        } else {
                                            for (let x = 0; x < len; x++) {
                                                finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot][x]);
                                            }
                                        }

                                    }
                                    //const randomStaff = this.getRandomNumber(slotWise.appliedStaff.length, howMuchWin);
                                });


                            } else { // if ops group quota value is less then total team quota
                                let allAppliedStaff = [];
                                slll.opsTeamQuotaValue.forEach((p, opsTeamQuotaValueIndex) => {
                                    ////console.logs('topIndexppppppp', topIndex, opsTeamQuotaValueIndex);
                                    if (appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex] && appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot]) {
                                        //console.logs('aaaaeee');
                                        if (p >= appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot].length) {
                                            // //console.logs('hh', appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex][''+slll.slot])
                                            allAppliedStaff = allAppliedStaff.concat(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot])
                                        } else {
                                            //console.logs('thiselseworkssss')
                                            const randomStaff = this.getRandomNumber(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot].length, p);
                                            randomStaff.forEach((ppp) => {
                                                allAppliedStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot][ppp])
                                            });
                                        }
                                        /*       //console.logs('bbb');
                                        const len = appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex][''+slll.slot].length;
                                        //console.logs('len', len, slll.slot, p);
                                        // p means no of win
                                        // len means no of applied
                                        if(len>p) {
                                            const randomStaff = this.getRandomNumber(len, p);
                                            //console.logs('randomStaff', randomStaff);
                                            randomStaff.forEach((randomSelectedStaff)=>{
                                                finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex][''+slll.slot][randomSelectedStaff])
                                            });
                                        }else {
                                            for(let x=0; x<len; x++){
                                                finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex][''+slll.slot][x]);
                                            }
                                        }*/
                                    }


                                    //const randomStaff = this.getRandomNumber(slotWise.appliedStaff.length, howMuchWin);
                                });
                                if (allAppliedStaff.length > 0) {
                                    //console.logs('ahugwgg')
                                    const finalAppliedStaff = [];
                                    const randomStaff = this.getRandomNumber(allAppliedStaff.length, allAppliedStaff.length);
                                    //console.logs('randomStaff', randomStaff, allAppliedStaff.length);
                                    randomStaff.forEach((ppp) => {
                                        finalAppliedStaff.push(allAppliedStaff[ppp])
                                    });
                                    const finalRandomStaff = this.getRandomNumber(allAppliedStaff.length, slll.opsGroupQuotaValue);
                                    //console.logs('finalRandomStaff', finalRandomStaff)
                                    //console.logs('sdhfys', allAppliedStaff.length, finalRandomStaff, slll.opsGroupQuotaValue);
                                    finalRandomStaff.forEach((ppp) => {
                                        finalWinStaff.push(finalAppliedStaff[ppp])
                                    });
                                }
                            }
                        });
                    });

                    const updateWin = await Ballot.findOneAndUpdate({_id: ballotId}, {
                        $set: {
                            wonStaff: finalWinStaff,
                            isResultRelease: true
                        }
                    })
                    this.unSuccessfullStaffLeaveBallotBalanaceUpdate(ballotId);
                    return res.status(200).json({
                        success: true,
                        message: 'Result release successfully',
                        finalWinStaff
                    });

                    // return res.status(200).json({
                    //     success:true,
                    //     opsGroupQuota,
                    //     appliedStaffArray,
                    //     finalWinStaff
                    // });
                }
            } else {
                return res.status(400).json({
                    success: false,
                    message: 'Ballot not found'
                });
            }


        } catch (e) {
            return res.status(500).json({status: false, data: null, message: 'Something went wrong', e});
        }
    }

    async unSuccessfullStaffLeaveBallotBalanaceUpdate(ballotId) {
        //console.logs('ballotId', ballotId)
        const ballotData = await Ballot.findOne({_id: ballotId});
        let leave = 5;
        if (ballotData.leaveConfiguration === 2) {
            leave = 6;
        } else if (ballotData.leaveConfiguration === 3) {
            leave = 7;
        }
        const appliedStaff = groupBy(ballotData.appliedStaff, 'userId');
        const wonStaff = groupBy(ballotData.wonStaff, 'userId');
        ////console.logs('ba', JSON.stringify(ballotData));
        const updateLeaveBy = [];
        for (let key in appliedStaff) {
            const obj = {
                userId: key,
                value: 0
            };
            const staffAppliedCount = appliedStaff[key].length;
            let staffWonCount = 0;
            if (wonStaff[key]) {
                staffWonCount = wonStaff[key].length;
            }
            obj.value = (staffAppliedCount - staffWonCount) * leave;
            updateLeaveBy.push(obj);
        }
        for (let i = 0; i < updateLeaveBy.length; i++) {
            const user = updateLeaveBy[i];
            //console.logs('user', user)
            if (user.value > 0) {
                const staffLevae = await StaffSapData.findOne({staff_Id: user.userId});
                if (staffLevae) {
                    let totalLeave = staffLevae.ballotLeaveBalanced + user.value;
                    if (totalLeave > staffLevae.leavesBalanced) {
                        totalLeave = staffLevae.leavesBalanced;
                    }
                    // //console.logs(staffLevae)
                    const update = await StaffSapData.update({staff_Id: user.userId}, {$set: {ballotLeaveBalanced: totalLeave}});
                }
            }
        }

        function groupBy(xs, key) {
            return xs.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };
    }

    getRandomNumber(length, howMany) {
        //console.logs("aaaaa")
        if (howMany > length) {
            howMany = length;
        }
        const arr = [];
        for (let i = 0; i < howMany; i++) {
            const num = Math.floor(Math.random() * (length - 0)) + 0;
            if (arr.includes(num)) {
                i = i - 1;
            } else {
                arr.push(num);
            }

        }
        return arr;
    }

    async readRestrictionForStaffForBallot(req, res) {
        try {
            const id = req.params.id;
            const ballot = await Ballot.findOne({_id: id});//{staffRestriction:1,maxSegment:1,maxConsecutiveBallot:1, isRestrict:1}
            const leave = await StaffSapData.findOne({staff_Id: req.user._id}, {ballotLeaveBalanced: 1});
            let ballotLeaveBalanced = 0;
            if (leave) {
                ballotLeaveBalanced = leave.ballotLeaveBalanced;
            }
            let leaveConfiguration = 5;
            if (ballot.leaveConfiguration === 2) {
                leaveConfiguration = 6;
            } else if (ballot.leaveConfiguration === 3) {
                leaveConfiguration = 7;
            }
            const howManySlotStaffCanApplied = Math.floor(ballotLeaveBalanced / leaveConfiguration);
            if (ballot.isRestrict) {
                const staffRestriction = [];
                ballot.staffRestriction.forEach((item) => {
                    let isPresent = false;
                    let staffRestrictionObj = {};
                    isPresent = item.userList.some((user) => {
                        ////console.logs('user',user)
                        if (user.id.toString() === req.user._id.toString()) {
                            staffRestrictionObj = {
                                "slot": item.slot,
                                "startDate": item.startDate,
                                "endDate": new Date(new Date(item.endDate).setDate(new Date(item.endDate).getDate() + 6)),
                            };
                            return true;
                        }
                    });
                    if (isPresent) {
                        const slot = this.getWeekIndex(item.startDate, ballot.weekRange, 'start');
                        staffRestrictionObj.slotNo = slot;
                        staffRestriction.push(staffRestrictionObj)
                    }
                });
                const segmentRestriction = [];
                ballot.maxSegment.forEach((item, index) => {
                    let startSlot = this.getWeekIndex(item.startDate, ballot.weekRange, 'start');
                    //console.logs('item.endDate', item.endDate);
                    let endSlot = this.getWeekIndex(item.endDate, ballot.weekRange, 'end');
                    let slotRange = [];
                    for (let i = startSlot; i <= endSlot; i++) {
                        slotRange.push(i);
                    }
                    let segmentRestrictionObj = {
                        startSlot,
                        endSlot,
                        slotRange,
                        maxBallot: item.maxBallot
                    };
                    segmentRestriction.push(segmentRestrictionObj);
                });
                var resTo = {
                    segmentRestriction: segmentRestriction,
                    leaveConfiguration: leaveConfiguration,
                    howManySlotStaffCanApplied: howManySlotStaffCanApplied,
                    isRestrict: true,
                    ballotLeaveBalanced: ballotLeaveBalanced,
                    staffRestriction: staffRestriction
                }
                return res.status(201).json({
                    success: true,
                    data: resTo,
                    message: 'Successfull'
                });
                // return res.status(200).json({segmentRestriction, leaveConfiguration, howManySlotStaffCanApplied, success: true,  isRestrict: true, ballotLeaveBalanced, staffRestriction});
            } else {
                var resTo = {

                    howManySlotStaffCanApplied: howManySlotStaffCanApplied,
                    isRestrict: true,
                    ballotLeaveBalanced: ballotLeaveBalanced,

                }
                return res.status(200).json({success: true, data: resTo, message: "successful"});
            }
        } catch (e) {
            return res.status(500).json({success: false, message: 'Something went wrong'});
        }
    }

    async getBallotFilteredResults(req, res) {
        //console.logs("IN GET");
        let data = req.body;
        let flag = 0;
        if (data.opsTeams && data.opsTeams.length > 0) {
            flag = 1
        }
        let ballot = await Ballot.findOne({_id: data.BallotId});
        let UsersIds = [];
        let appliedCount = 0;
        let successfulCount = 0;
        if (data.opsGroups && data.opsGroups.length > 0) {
            for (var i = 0; i <= data.opsGroups.length - 1; i++) {
                var OpsG = await OpsGroup.findOne({_id: data.opsGroups[i]});
                if (!OpsG) {
                    return res.status(400).json({success: false, message: 'Selected ops group not found'});
                } else {
                    if (flag == 0) {
                        UsersIds = UsersIds.concat(OpsG.userId);
                    } else {

                        for (var a = 0; a <= OpsG.opsTeamId.length - 1; a++) {
                            for (var b = 0; b <= data.opsTeams.length - 1; b++) {
                                //console.logs("ID!: ", data.opsTeams[b], " ID@: ", OpsG.opsTeamId[a]);
                                if (data.opsTeams[b].toString() === OpsG.opsTeamId[a].toString()) {
                                    //console.logs("SAME FOUND");
                                    //here me now
                                    var OpsT = await OpsTeam.findOne({_id: data.opsTeams[b]});
                                    if (!OpsT) {
                                        //console.logs("same team not found");

                                    } else {
                                        UsersIds = UsersIds.concat(OpsT.userId)
                                    }
                                    //UsersIds.push(data.opsTeams[b]);
                                } else {
                                    //console.logs("NOt same team Id found");
                                }
                            }
                        }

                    }


                }
            }

            if (ballot.appliedStaff.length > 0) {
                for (var i = 0; i <= ballot.appliedStaff.length - 1; i++) {
                    for (var j = 0; j <= UsersIds.length - 1; j++) {
                        if (ballot.appliedStaff[i].userId.toString() === UsersIds[j].toString()) {
                            //same user found
                            //console.logs("MATCH YEP YEP");
                            appliedCount = appliedCount + 1;
                            // let user = await User.findOne({_id:})
                        } else {
                            //console.logs("not equal applied staff");
                        }
                    }

                }
            }
            if (ballot.isResultRelease === true) {
                for (var i = 0; i <= ballot.wonStaff.length - 1; i++) {
                    for (var j = 0; j <= UsersIds.length - 1; j++) {
                        if (ballot.wonStaff[i].userId.toString() === UsersIds[j].toString()) {
                            //same user found
                            //console.logs("MATCH YEP YEP");
                            successfulCount = successfulCount + 1;
                            // let user = await User.findOne({_id:})
                        } else {
                            //console.logs("not equal applied staff");
                        }
                    }

                }

            } else {
                //console.logs("result not released.");
            }

            res.send({users: UsersIds, applied: appliedCount, success: successfulCount});
        } else {
            return res.status(500).json({success: false, message: 'please select at least one ops group'});
        }

        //console.logs("USerIds found: ", UsersIds);


    }

    getWeekIndex(date, weekRange, from) {
        if (from === 'end') {
            let weekDay = new Date(date).getDay();
            if (weekDay !== 0) {
                date = new Date(date);
                date.setDate(new Date(date).getDate() + 7 - weekDay);
            }
        } else {
            let weekDay = new Date(date).getDay();
            if (weekDay !== 1) {
                date = new Date(date);
                date.setDate(new Date(date).getDate() + 1 - weekDay);
            }
        }
        const yeterday = new Date(date);
        yeterday.setDate(new Date(date).getDate() - 1);
        const lastDate = moment(yeterday).format('YYYY-MM-DD');
        const currentDate = moment(date).format('YYYY-MM-DD');
        const tomorrow = new Date(date);
        tomorrow.setDate(new Date(date).getDate() + 1);
        const nextDate = moment(tomorrow).format('YYYY-MM-DD');
        // //console.logs('last', lastDate);
        //console.logs('currentDate', currentDate);
        // //console.logs('weekRange[i]', weekRange[0])
        //   //console.logs('nextDate', nextDate);
        let slot = -1;
        if (from === 'start') {
            for (let i = 0; i < weekRange.length; i++) {
                const item = weekRange[i];
                if (new Date(item.start).getTime() === new Date(currentDate).getTime()) {
                    slot = i;
                    break;
                }
            }
        } else {
            for (let i = 0; i < weekRange.length; i++) {
                const item = weekRange[i];
                if (new Date(item.end).getTime() === new Date(currentDate).getTime()) {
                    slot = i;
                    break;
                }
            }
        }
        return slot;

    }

    async extendBallot(req, res) {
        let id = req.params.id;
        var data = req.body;
        let ballot = await Ballot.findOne({_id: id});


        if (!ballot) {
            return res.status(500).json({success: false, message: 'Requested ballot not found'});
        } else {
            let oldClosingDate = ballot.applicationCloseDateTime;
            //console.logs("DATA IS: ", data.applicationCloseDateTime);
            let date = data.applicationCloseDateTime;
            let date1 = data.resultReleaseDateTime;
            date = moment(date, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            //console.logs("data: ", date);
            const validationObj = this.validatieEndBallotDate(date);
            if (validationObj.status) {
                let updates = await Ballot.update({_id: id}, {
                    $set: {applicationCloseDateTime: date, resultReleaseDateTime:date1},
                    $push: {ballotExtendLogs: oldClosingDate}
                });
                ballotExtendNotifications(ballot);
                //,{$push:{ballotExtendLogs:oldClosingDate}}
                return res.status(201).json({status: true, message: "Ballot extended successfully", data: updates});
            } else {
                return res.json({status: false, message: "There are some date are not in valid format"});
            }

        }
    }

    validatieEndBallotDate(data) {
        if (data === 'Invalid date') {
            return {status: false, message: "There are some date are not in valid format"}
        }
        return {status: true}
    }

    async cancelBallot(req, res) {
        let id = req.params.id;
        const ballotData = await Ballot.findOne({_id: id});
        let leave = 5;
        if (ballotData.leaveConfiguration === 2) {
            leave = 6;
        } else if (ballotData.leaveConfiguration === 3) {
            leave = 7;
        }
        const appliedStaff = groupBy(ballotData.appliedStaff, 'userId');
        const wonStaff = groupBy(ballotData.wonStaff, 'userId');
        const updateLeaveBy = [];
        //console.logs("Applied is: ", appliedStaff);
        //console.logs("WONSTAFF IS: ", wonStaff);
        for (let key in appliedStaff) {
            const obj = {
                userId: key,
                value: 0
            };
            const staffAppliedCount = appliedStaff[key].length;
            let staffWonCount = 0;
            if (wonStaff[key]) {
                staffWonCount = wonStaff[key].length;
            }
            obj.value = (staffAppliedCount - staffWonCount) * leave;
            updateLeaveBy.push(obj);
        }
        //console.logs("updateLeaveBy:", updateLeaveBy);
        for (let i = 0; i < updateLeaveBy.length; i++) {
            const user = updateLeaveBy[i];
            //console.logs('user', user)
            if (user.value > 0) {
                const staffLeavedata = await StaffSapData.findOne({staff_Id: user.userId});
                if (staffLeavedata) {
                    let totalLeave = staffLeavedata.ballotLeaveBalanced + user.value;
                    if (totalLeave > staffLeavedata.leavesBalanced) {
                        totalLeave = staffLeavedata.leavesBalanced;
                    }
                    //console.logs("staffLeavedata: ", staffLeavedata);
                    const update = await StaffSapData.update({staff_Id: user.userId}, {$set: {ballotLeaveBalanced: totalLeave}});
                }
            }
        }

        const ballotupdate = await Ballot.update({_id: id}, {isCanceled: true});
        ballotCancelledNotifications(ballotData);
        return res.status(201).json({status: true, message: "Ballot Cancelled successfully."});

        function groupBy(xs, key) {
            return xs.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };

    }

    async reBallot(req, res) {
        let id = req.params.id;
        const ballot = await Ballot.findOne({_id: id}).populate([{
            path:'adminId',
            select:'_id name staffId'
        },{path:'opsGroupId',model:'OpsGroup',select:'_id opsGroupName'}
       ]);
    
        if (!ballot) {
            return res.status(500).json({success: false, message: 'Requested ballot not found'});
        } else {
            let newballot = JSON.stringify(ballot);
            newballot = JSON.parse(newballot);
            newballot.parentBallot = ballot._id;
            newballot.applicationOpenDateTime = "";
            newballot.applicationCloseDateTime = "";
            // newballot.applicationOpenDateTime = new Date();
            // newballot.applicationCloseDateTime = moment(newballot.applicationOpenDateTime).add(10, 'd').toDate();
            // newballot.ballotStartDate = moment(newballot.applicationOpenDateTime ).add(20, 'd').toDate();
            // newballot.ballotEndDate =moment(newballot.applicationOpenDateTime ).add(45, 'd').toDate();

            newballot.resultReleaseDateTime = moment(newballot.applicationOpenDateTime).add(15, 'd').toDate();

            //start with remainng quotas
            let slots = ballot.slotCreation;
            if (newballot.userFrom === 2) {
                //FOr BU's
                for (let i = 0; i <= slots.length - 1; i++) {
                    // let users = [];
                    //const users = await User.find({parentBussinessUnitId : slots[i].buId},{_id:1,name:1});
                    for (let j = 0; j <= slots[i].arr.length - 1; j++) {
                        var found = ballot.wonStaff.filter(function (element) {
                            return (element.buId.toString() === slots[i].buId.toString() && element.weekNo === j)
                        });
                        //console.logs("FOUND: ", found);
                        slots[i].arr[j].value = slots[i].arr[j].value - found.length;

                    }
                    //res.send(users)


                }

            } else {
                //For Ops groups

                for (let i = 0; i <= slots.length - 1; i++) {
                    let opsGrpid = slots[i].opsGroup.opsId;
                    for (let j = 0; j <= slots[i].arr.length - 1; j++) {
                        let currentweek = j + 'A';
                        var found = ballot.wonStaff.filter(function (element) {
                            return (element.opsGroupId.toString() === opsGrpid.toString() && element.weekNo === j)
                        });

                        slots[i].weekRangeSlot[currentweek].value = slots[i].weekRangeSlot[currentweek].value - found.length;
                        if (slots[i].opsTeam.length > 0) {
                            slots[i].opsTeam.forEach((team, d) => {
                                let currentweek = j + d.toString();
                                //console.logs("Current week in Team: ", currentweek);
                                var found = ballot.wonStaff.filter(function (element) {

                                    if(element.opsTeamId){
                                    return (element.opsTeamId.toString() === team._id.toString() && element.weekNo === j)
                                    }else{
                                        return (element.opsGroupId===opsGrpid && !element.opsTeamId && element.weekNO===j)
                                    }

                                });
                                //console.logs("FOUND: ", found);
                                slots[i].weekRangeSlot[currentweek].value = slots[i].weekRangeSlot[currentweek].value - found.length;
                            })
                        }
                    }

                }


            }
            newballot.slotCreation = slots;
            newballot.appliedStaff = [];
            newballot.wonStaff = [];
            newballot.isPublish = false;
            newballot.isDraft = false;
            newballot.isResultRelease = false;

            return res.status(201).json({status: true, data: newballot, message: "Received data."});


        }
    }

    async getBallotAppliedUsersList(req, res) {
        //console.logs("USER ID: ", req.params.id);
        try {
            let ballot = await Ballot.findById({_id: req.params.id}).populate(
                [{path: 'appliedStaff.userId', select: "_id name"},
                    {path: 'wonStaff.userId', select: "_id name"}
                ]);
            //let Applied=[]; let WON=[];
            let weekRange = ballot.weekRange;
            weekRange.map(week => {
                week.appliedUser = [];
                week.wonUser = [];
            });
            //console.logs("WEEKRANGE IS : ", weekRange);
            ballot = JSON.stringify(ballot);
            ballot = JSON.parse(ballot);
            if (ballot) {
                if (ballot.appliedStaff.length > 0) {
                    for (var i = 0; i <= ballot.appliedStaff.length - 1; i++) {
                        let SlotObject = ballot.appliedStaff[i];
                        //   var slot = ballot.weekRange[SlotObject.weekNo];

                        weekRange[SlotObject.weekNo].appliedUser.push(SlotObject.userId);
                        ////console.logs("IN APPLIED :",weekRange[SlotObject.weekNO]);
                        //  SlotObject.slot={};
                        // SlotObject.slot= {start:slot.start,end:slot.end};
                        // Applied.push(SlotObject);
                    }
                }
                //console.logs("WIN STAFF ARE: ", ballot.wonStaff.length);
                if (ballot.wonStaff.length > 0) {
                    for (var i = 0; i <= ballot.wonStaff.length - 1; i++) {
                        let SlotObject = ballot.wonStaff[i];

                        // var slot = ballot.weekRange[SlotObject.weekNo];
                        weekRange[SlotObject.weekNo].wonUser.push(SlotObject.userId);
                        // weekRange[SlotObject.weekNO].wonUser.push(SlotObject.userId);
                        // SlotObject.slot={};
                        //SlotObject.slot= {start:slot.start,end:slot.end};
                        //WON.push(SlotObject);
                    }
                }
                // //console.logs("DONE WITH SECOND");


                //console.logs("CALLING THIS THEN");
                let ballotingdata = {weeks: weekRange};
                res.status(200).json({status: true, data: ballotingdata, message: 'data retrieved successfully'});
            } else {
                res.send("couldent found");
            }
        } catch (e) {
            return res.status(500).json({status: false, data: e, message: 'something went wrong', e});
        }

    }

    async getOpsTeamdropedown(req, res) {
        let id = req.params.id;
        let opsData = [];
        const ballot = await Ballot.findOne({_id: id});
        const opsGroupId = ballot.opsGroupId;
        if (!ballot) {
            return res.status(500).json({success: false, message: 'Requested ballot not found'});
        } else {
            for (let i = 0; i <= opsGroupId.length - 1; i++) {
                let ops = {};
                let opsG = await OpsGroup.findOne({_id: opsGroupId[i]}, {opsGroupName: 1, _id: 1, opsTeamId: 1});
                if (!opsG) {
                    return res.status(500).json({success: false, message: 'Couldnt find respective ops group'});
                } else {
                    ops.opsgroup = opsG;
                    let teams = [];
                    let Teams = opsG.opsTeamId;
                    //console.logs("OPSGROUP IS: ", opsG);
                    //console.logs("TEAMS : ", opsG.opsTeamId);
                    if (Teams.length > 0) {
                        for (let j = 0; j <= Teams.length - 1; j++) {

                            let OpsT = await OpsTeam.findOne({_id: Teams[j]}, {_id: 1, name: 1});
                            teams.push(OpsT);

                        }
                    }
                    ops.Teams = teams;
                }
                opsData.push(ops);
            }
            //console.logs("data found is: ", opsData);
            return res.status(200).json({
                success: true,
                data: opsData,
                message: 'Successfully received ops data for respectd ballot'
            });

        }
    }


    async getBallotInRounds(req, res) {
        //first check if ballot has parent ballot

        try {
            const ballot = await Ballot.findOne({_id: req.params.id});

            if (!ballot) {
                return res.status(500).json({success: false, message: 'Requested ballot not found'});
            } else {
                if (ballot.parentBallot) {
                    let parentBallotId = await this.checkBallots(ballot._id);
                    //console.logs("parentballet", parentBallotId);
                    const ballotparent = await Ballot.findOne({_id: parentBallotId}, {
                        _id: 1,
                        ballotName: 1,
                        resultReleaseDateTime: 1,
                        childBallots: 1,
                        ballotRound: 1,
                        isResultRelease: 1,
                        applicationOpenDateTime: 1,
                        applicationCloseDateTime: 1,
                        isConduct:1,
                        resultRelease:1,
                        isAutoAssign:1
                    });
                    //console.logs("ballotparent: ", ballotparent);
                    this.sendManageBallotData(ballotparent, res);

                } else {
                    //console.logs("In main else");
                    this.sendManageBallotData(ballot, res);

                }

            }

        } catch (e) {
            return res.status(500).json({success: false, message: 'Something went wrong!'});
        }

    }

    async checkBallots(ballotid) {
        let newballot = await Ballot.findOne({_id: ballotid});
        //console.logs("NewBallot: ", newballot);
        newballot = JSON.stringify(newballot);
        newballot = JSON.parse(newballot);
        if (newballot.parentBallot) {

            let id = newballot.parentBallot;

            return this.checkBallots(id);
        } else {
            // return ballot
            //console.logs("in else of check parent ballot: ", newballot._id);
            return newballot._id;
        }
    }

    async sendManageBallotData(ballot, res) {
        let BallotsList = [];
        let ballotStatus = 'Open';
        if (new Date().getTime() > new Date(ballot.applicationCloseDateTime).getTime()) {

            ballotStatus = 'Closed';
        }
        if (ballot.isResultRelease) {
            //console.logs("In check of result release yep");
            ballotStatus = 'Closed';
        }
        //console.logs("Ballot status is:", ballotStatus);
        let roundOne = ballot.ballotRound + 1;
        let newbal = {
            ballotName: ballot.ballotName,
            _id: ballot._id,
            ballotStatus: ballotStatus,
            ballotRound: 'Round ' + roundOne,
            resultDate: ballot.resultReleaseDateTime,
            applicationOpenDateTime: ballot.applicationOpenDateTime,
            applicationCloseDateTime: ballot.applicationCloseDateTime,
            isResultRelease: ballot.isResultRelease,
            isConduct:ballot.isConduct,
            resultRelease:ballot.resultRelease,
            isAutoAssign:ballot.isAutoAssign

        }
        BallotsList.push(newbal);
        let parentBallotMain = ballot._id;
        if (ballot.childBallots && ballot.childBallots.length > 0) {
            for (let b = 0; b <= ballot.childBallots.length - 1; b++) {
                let childBallot = await Ballot.findOne({_id: ballot.childBallots[b]}, {
                    _id: 1, ballotName: 1, resultReleaseDateTime: 1,
                    ballotRound: 1, isResultRelease: 1, applicationOpenDateTime: 1, applicationCloseDateTime: 1, isConduct:1,
                    resultRelease:1,isAutoAssign:1,assignRatio:1
                });
              //  console.log("Child Ballots : ", childBallot._id,'=>',childBallot.isAutoAssign);
                if (childBallot) {
                    let Status = 'Open';
                    if (new Date().getTime() > new Date(childBallot.applicationCloseDateTime).getTime()) {

                        Status = 'Closed';
                    }
                    if (childBallot.isResultRelease) {
                        //console.logs("In check of result release yep of child ballot");
                        Status = 'Closed';
                    }

                    let roundChild = childBallot.ballotRound + 1;
                    let newbal1 = {
                        ballotName: childBallot.ballotName,
                        _id: childBallot._id,
                        ballotStatus: Status,
                        ballotRound: 'Round ' + roundChild,
                        resultDate: childBallot.resultReleaseDateTime,
                        applicationOpenDateTime: childBallot.applicationOpenDateTime,
                        applicationCloseDateTime: childBallot.applicationCloseDateTime,
                        isResultRelease: childBallot.isResultRelease,
                        isConduct:childBallot.isConduct,
                        resultRelease:childBallot.resultRelease,
                        isAutoAssign:childBallot.isAutoAssign,
                       
                    }
                    if(!childBallot.assignRatio){
                        childBallot.isAssignRatio=false;
                    }else{
                        childBallot.isAssignRatio=true;
                        childBallot.assignRatio = childBallot.assignRatio
                    }
                    BallotsList.push(newbal1);
                } else {
                    return res.status(500).json({
                        success: false,
                        message: 'Problem while finding child ballots, Please try again later'
                    });
                }

                //console.logs("BallotsList :", BallotsList);
            }
        } else {
            //console.logs("There is no child ballot yet");
        }
        BallotsList.reverse();
        let ballotData = {parent: parentBallotMain, BallotList: BallotsList};
        return res.status(200).json({success: true, data: ballotData, message: 'Successfully got data.'});

    }

    async resultRelase(req, res){
        const selectedBallotId = req.body.selectedBallotId;
        let user = await Ballot.findOneAndUpdate({_id:selectedBallotId},{$set:{isResultRelease:true, resultReleaseDateTime: new Date()}});
        //call a created method which will save won users of this ballot in userHoliday collection.
        console.log("USER : ",user);
        this.saveWonsAllAsLeave(user.wonStaff,user.weekRange,user.ballotRound,user._id);
        return res.json({success: true, message: 'Result Release successfully'});
    }

    async ballotDetail(req, res) {
        // try{
        const selectedBallotId = req.body.selectedBallotId;
        const ballotData = await Ballot.findOne({_id: selectedBallotId});
        // for BU
        if (ballotData.userFrom === 2) {
            const wonStaffData = [];
            const wonStaffByBu = this.groupByPro(ballotData.wonStaff, 'buId');
            for (let buId in wonStaffByBu) {
                const wonStaffByBu_Week = this.groupByPro(wonStaffByBu[buId], 'weekNo');
                wonStaffData.push({buId, wonStaffByBu_Week})
            }
            const appliedStaffData = [];
            const appliedStaffDataByBu = this.groupByPro(ballotData.appliedStaff, 'buId');
            for (let buId in appliedStaffDataByBu) {
                const appliedStaffDataByBu_Week = this.groupByPro(appliedStaffDataByBu[buId], 'weekNo');
                appliedStaffData.push({buId1: buId, appliedStaffDataByBu_Week})
            }
            const actualSlotValueByBuArr = [];
            const ballotRoundResult = {
                quota: 0,
                applied: 0,
                successful: 0
            };
            for (let i = 0; i < ballotData.slotCreation.length; i++) {
                const slot = ballotData.slotCreation[i];
                // //console.logs('slot', slot);
                const wonBuStaffArr = wonStaffData.filter((bu) => {
                    return bu.buId == slot.buId;
                });
                const appliedBuStaffArr = appliedStaffData.filter((bu) => {
                    return bu.buId1 == slot.buId;
                });
                let appliedBuStaff = null;
                let wonBuStaff = null;
                if (appliedBuStaffArr.length > 0) {
                    appliedBuStaff = appliedBuStaffArr[0];
                }
                if (wonBuStaffArr.length > 0) {
                    wonBuStaff = wonBuStaffArr[0];
                }
                const actualSlotValueByBu = {
                    buId: slot.buId,
                    weekValue: [],
                    ballotRoundResultBuWise: {
                        quota: 0,
                        applied: 0,
                        successful: 0
                    }
                };
                slot.arr.forEach((item, index) => {
                    const slotValue = item.value;
                    ballotRoundResult.quota = ballotRoundResult.quota + slotValue;
                    actualSlotValueByBu.ballotRoundResultBuWise.quota = actualSlotValueByBu.ballotRoundResultBuWise.quota + slotValue;
                    let appliedValue = 0;
                    if (appliedBuStaff && appliedBuStaff.appliedStaffDataByBu_Week['' + index]) {
                        appliedValue = appliedBuStaff.appliedStaffDataByBu_Week['' + index].length;
                        ballotRoundResult.applied = ballotRoundResult.applied + appliedValue;
                        actualSlotValueByBu.ballotRoundResultBuWise.applied = actualSlotValueByBu.ballotRoundResultBuWise.applied + appliedValue;

                    }


                    let wonValue = 0;
                    if (wonBuStaff && wonBuStaff.wonStaffByBu_Week['' + index]) {
                        wonValue = wonBuStaff.wonStaffByBu_Week['' + index].length;
                        ballotRoundResult.successful = ballotRoundResult.successful + wonValue;
                        actualSlotValueByBu.ballotRoundResultBuWise.successful = actualSlotValueByBu.ballotRoundResultBuWise.successful + wonValue;
                    }

                    actualSlotValueByBu.weekValue.push(`${slotValue}/${appliedValue}/${wonValue}`);

                });
                actualSlotValueByBuArr.push(actualSlotValueByBu)
            }
            res.send({actualSlotValueByBuArr, ballotRoundResult});
        } else {
            const wonStaffDataOpsGroup = [];
            const wonStaffByOpsGroup = this.groupByPro(ballotData.wonStaff, 'opsGroupId');
            for (let opsGroupId in wonStaffByOpsGroup) {
                const wonStaffByBu_Week = this.groupByPro(wonStaffByOpsGroup[opsGroupId], 'weekNo');
                wonStaffDataOpsGroup.push({opsGroupId, wonStaffByBu_Week})
            }
            //console.logs('wonStaffDataOpsGroup', JSON.stringify(wonStaffDataOpsGroup));
            const wonStaffDataOpsTeam = [];
            const wonStaffByOpsTeam = this.groupByPro(ballotData.wonStaff, 'opsTeamId');
            for (let opsTeamId in wonStaffByOpsTeam) {
                const opsGroupId = wonStaffByOpsTeam[opsTeamId][0].opsGroupId;
                const wonStaffByBu_Week = this.groupByPro(wonStaffByOpsTeam[opsTeamId], 'weekNo');
                wonStaffDataOpsTeam.push({opsTeamId, opsGroupId, wonStaffByBu_Week})
            }


            const appliedStaffDataOpsGroup = [];
            const appliedStaffDataByOpsGroup = this.groupByPro(ballotData.appliedStaff, 'opsGroupId');
            //console.logs('*******');
            // //console.logs('appliedStaffDataByOpsGroup', JSON.stringify(appliedStaffDataByOpsGroup));
            //console.logs('*******');
            for (let opsGroupId in appliedStaffDataByOpsGroup) {
                const appliedStaffDataByBu_Week = this.groupByPro(appliedStaffDataByOpsGroup[opsGroupId], 'weekNo');
                appliedStaffDataOpsGroup.push({opsGroupId: opsGroupId, appliedStaffDataByBu_Week})
            }
            //console.logs('appliedStaffDataOpsGroup', JSON.stringify(appliedStaffDataOpsGroup));
            //console.logs('*******');
            const appliedStaffDataOpsTeam = [];
            const appliedStaffDataByOpsTeam = this.groupByPro(ballotData.appliedStaff, 'opsTeamId');
            for (let opsTeamId in appliedStaffDataByOpsTeam) {
                const opsGroupId = appliedStaffDataByOpsTeam[opsTeamId][0].opsGroupId;
                const appliedStaffDataByBu_Week = this.groupByPro(appliedStaffDataByOpsTeam[opsTeamId], 'weekNo');
                appliedStaffDataOpsTeam.push({opsTeamId: opsTeamId, opsGroupId, appliedStaffDataByBu_Week})
            }
            //return res.json({appliedStaffDataOpsTeam,wonStaffDataOpsTeam, wonStaffDataOpsGroup, appliedStaffDataOpsGroup, ballotData});
            let finalValue = [];
            let finalValueTeam = [];
            for (let i = 0; i < ballotData.slotCreation.length; i++) {
                const slotObj = ballotData.slotCreation[i];
                if(slotObj.opsTeam.length>0){
                // //console.logs('appliedStaffDataOpsTeam', appliedStaffDataOpsTeam);
                const appliedStaffOpsTeamArr = [];
                appliedStaffDataOpsTeam.forEach((item) => {
                    for (let i = 0; i < slotObj.opsTeam.length; i++) {
                        if (slotObj.opsTeam[i]._id == item.opsTeamId) {
                            appliedStaffOpsTeamArr.push(item);
                        }
                    }
                });

                const wonStaffOpsTeamArr = [];
                wonStaffDataOpsTeam.forEach((item) => {
                    ////console.logs('itemitem', item);
                    for (let i = 0; i < slotObj.opsTeam.length; i++) {
                        // //console.logs('i', i);
                        //console.logs('slotObj.opsTeam[i]', slotObj.opsTeam[i]._id, item.opsTeamId);
                        if (slotObj.opsTeam[i]._id == item.opsTeamId) {
                            //console.logs('hchchchchhc')
                            wonStaffOpsTeamArr.push(item);
                        }
                    }
                });
                // //console.logs('wonStaffOpsTeamArr', wonStaffOpsTeamArr.length);
                const tire1Quota = [];
                finalValueTeam = [];
                slotObj.opsTeam.forEach((team, index) => {

                    const teamWiseQuota = {
                        teamQuota: 0,
                        applied: 0,
                        success: 0
                    };
                    const appliedStaffTeamObj = appliedStaffOpsTeamArr.filter((appliedTeam) => {
                        return appliedTeam.opsTeamId == team._id;
                    });

                    const wonStaffTeamObj = wonStaffOpsTeamArr.filter((wonTeam) => {
                        return wonTeam.opsTeamId == team._id;
                    });
                    ////console.logs('wonStaffTeamObj', wonStaffTeamObj);
                    let teamSlotArr = []
                    for (let j = 0; j < ballotData.weekRange.length; j++) {
                        if (index === 0) {

                            tire1Quota.push(parseInt(slotObj.weekRangeSlot['' + j + 'A'].value));
                        }


                        const week = ballotData.weekRange[j];
                        const teamQuota = parseInt(slotObj.weekRangeSlot['' + j + index].value);
                        let appliedStaffQuota = 0;
                        let successStaffQuota = 0;

                        if (appliedStaffTeamObj.length > 0 && appliedStaffTeamObj[0].appliedStaffDataByBu_Week['' + j]) {
                            ////console.logs('aa')
                            appliedStaffQuota = appliedStaffTeamObj[0].appliedStaffDataByBu_Week['' + j].length

                        }
                        if (wonStaffTeamObj.length > 0 && wonStaffTeamObj[0].wonStaffByBu_Week['' + j]) {
                            // //console.logs('aa')
                            successStaffQuota = wonStaffTeamObj[0].wonStaffByBu_Week['' + j].length

                        }
                        //console.logs('before push', teamQuota, typeof teamQuota)
                        teamSlotArr.push({teamQuota, appliedStaffQuota, weekNo: j, successStaffQuota});

                    }
                    //tire1Quota
                    let obj = {
                        teamId: team._id,
                        opsGroupId: slotObj.opsGroup.opsId,
                        value: teamSlotArr
                    };

                    /*   obj[''+team._id] = [];
                       obj[''+team._id] = teamSlotArr;
                       obj.tire1Quota = tire1Quota;*/
                    finalValueTeam.push(obj);


                    teamSlotArr = [];
                    if (index === slotObj.opsTeam.length - 1) {
                        for (let k = 0; k < ballotData.weekRange.length; k++) {
                            let totalTeamQuota = 0;
                            let totalTeamSuccess = 0;
                            let totalTeamApplied = 0;
                            slotObj.opsTeam.forEach((insideTeam, indexIndex) => {
                                //totalTeamQuota = totalTeamQuota + finalValueTeam[indexIndex].value[k].teamQuota;
                                totalTeamSuccess = totalTeamSuccess + finalValueTeam[indexIndex].value[k].successStaffQuota;
                                totalTeamApplied = totalTeamApplied + finalValueTeam[indexIndex].value[k].appliedStaffQuota;
                            });
                            //totalTeamQuota = totalTeamQuota + finalValueTeam[indexIndex].value[k].teamQuota;
                            teamSlotArr.push({
                                teamQuota: tire1Quota[k],
                                appliedStaffQuota: totalTeamApplied,
                                weekNo: k,
                                successStaffQuota: totalTeamSuccess
                            });

                        }
                        obj = {
                            teamId: 'Tier 1',
                            opsGroupId: slotObj.opsGroup.opsId,
                            value: teamSlotArr
                        };
                        finalValueTeam.push(obj);
                    }
                });

                finalValue.push(finalValueTeam);

            } else{
                    // no team detail
                    finalValueTeam = [];
                   const noOpsTeamAppliedDataArr =  appliedStaffDataOpsGroup.filter((item)=>{
                       return item.opsGroupId == slotObj.opsGroup.opsId;
                   });
                    const noOpsTeamWonDataArr =  wonStaffDataOpsGroup.filter((item)=>{
                        return item.opsGroupId == slotObj.opsGroup.opsId;
                    });
                    let obj = {
                        teamId: null,
                        opsGroupId: slotObj.opsGroup.opsId,
                        value: []
                    };
                    let teamSlotArr = [];
                    for(let i=0; i<ballotData.weekRange.length; i++){
                        let teamQuota = parseInt(slotObj.weekRangeSlot[''+i+'A'].value);
                        let appliedStaffQuota = 0;
                        if(noOpsTeamAppliedDataArr && noOpsTeamAppliedDataArr.length>0 && noOpsTeamAppliedDataArr[0].appliedStaffDataByBu_Week[i] && noOpsTeamAppliedDataArr[0].appliedStaffDataByBu_Week[i].length>0) {
                            appliedStaffQuota = noOpsTeamAppliedDataArr[0].appliedStaffDataByBu_Week[i].length;
                            //console.logs("HERE AT QUOTA: ",appliedStaffQuota);
                        }
                        let successStaffQuota = 0;
                        if(noOpsTeamWonDataArr && noOpsTeamWonDataArr.length && noOpsTeamWonDataArr[0].wonStaffByBu_Week[i] && noOpsTeamWonDataArr[0].wonStaffByBu_Week[i].length>0) {
                            successStaffQuota = noOpsTeamWonDataArr[0].wonStaffByBu_Week[i].length;
                        }
                        //console.logs('before push', teamQuota, typeof teamQuota)
                        teamSlotArr.push({teamQuota, appliedStaffQuota, weekNo: i, successStaffQuota});
                    }
                    obj.value = teamSlotArr;
                    finalValueTeam.push(obj);
                    finalValue.push(finalValueTeam);
                }
            };
            //return res.json({finalValue})
            console.log("Final value is: ",finalValue);
            const newFinalData = [];
            let finalTotalApplied = 0;
            let finalTotalQuota = 0;
            let totalTeamQuota = 0 ;
            let finalTotalSuccessful = 0;
            for (let i = 0; i < ballotData.slotCreation.length; i++) {
                const slotData = ballotData.slotCreation[i];
                const opsGroupData = finalValue[i];
                let totalBalanceTeamQuota = 0;
                slotData.opsGroup.balanceQuota = 0;
                slotData.opsGroup.applied = 0;
                slotData.opsGroup.quota = 0;
                slotData.opsGroup.successful = 0;

                for (let j = 0; j < opsGroupData.length; j++) {
                    if (opsGroupData.length - 1 !== j) {
                        slotData.opsTeam[j].balanceQuota = 0;
                        slotData.opsTeam[j].applied = 0;
                        slotData.opsTeam[j].quota = 0;
                        slotData.opsTeam[j].successful = 0;
                    }
                }
                    for (let k = 0; k < ballotData.weekRange.length; k++) {
                        let teamQuota = 0;
                        let teamBallanceReaming = 0;
                    for (let j = 0; j < opsGroupData.length; j++) {
                        if (opsGroupData.length - 1 === j) {
                            // for tire 1
                            //slotData.opsTeam[j].isShow = true;
                            if(opsGroupData.length === 1){
                                slotData.opsGroup.applied += opsGroupData[j].value[k].appliedStaffQuota;
                               // slotData.opsGroup.quota +=  opsGroupData[j].value[k].teamQuota;
                                slotData.opsGroup.successful +=  opsGroupData[j].value[k].successStaffQuota;
                            }
                            slotData.weekRangeSlot[''+k+'A'].value =opsGroupData[j].value[k];
                            ////console.logs('opsGroupData[j].value[k]', opsGroupData[j].value[k]);
                            finalTotalApplied +=opsGroupData[j].value[k].appliedStaffQuota;
                            finalTotalSuccessful +=opsGroupData[j].value[k].successStaffQuota;
                            slotData.opsGroup.balanceQuota += opsGroupData[j].value[k].teamQuota -  opsGroupData[j].value[k].successStaffQuota ;
                            //console.logs('teamBallanceReamingteamBallanceReaming', teamBallanceReaming, slotData.opsGroup.balanceQuota)
                            if(teamBallanceReaming <  slotData.opsGroup.balanceQuota && opsGroupData.length !== 1){
                                slotData.opsGroup.balanceQuota = teamBallanceReaming;
                            }
                            //console.logs('finalTotalQuotafinalTotalQuota', finalTotalQuota, teamQuota, opsGroupData[j].value[k].teamQuota)
                            if(teamQuota<opsGroupData[j].value[k].teamQuota && opsGroupData.length>1){
                                finalTotalQuota += parseInt(teamQuota);
                                slotData.opsGroup.quota += parseInt(teamQuota);
                            }else {
                                finalTotalQuota += parseInt(opsGroupData[j].value[k].teamQuota);
                                slotData.opsGroup.quota += parseInt(opsGroupData[j].value[k].teamQuota);
                            }
                        } else {
                            slotData.opsTeam[j].isShow = true;
                            slotData.weekRangeSlot[''+k+j].value =opsGroupData[j].value[k];
                            slotData.opsTeam[j].balanceQuota += opsGroupData[j].value[k].teamQuota -  opsGroupData[j].value[k].successStaffQuota;
                            slotData.opsTeam[j].applied += opsGroupData[j].value[k].appliedStaffQuota;
                            slotData.opsTeam[j].quota += opsGroupData[j].value[k].teamQuota;
                            //console.logs('opsGroupData[j].value[k].teamQuota', typeof opsGroupData[j].value[k].teamQuota)
                            teamQuota +=  parseInt(opsGroupData[j].value[k].teamQuota);
                            totalTeamQuota += slotData.opsTeam[j].quota
                            slotData.opsTeam[j].successful += opsGroupData[j].value[k].successStaffQuota;
                            slotData.opsGroup.applied += opsGroupData[j].value[k].appliedStaffQuota;
                            //slotData.opsGroup.quota +=  opsGroupData[j].value[k].teamQuota;
                            slotData.opsGroup.successful +=  opsGroupData[j].value[k].successStaffQuota;
                        }
                        if (opsGroupData.length - 1 !== j) {
                            totalBalanceTeamQuota += slotData.opsTeam[j].balanceQuota;
                            teamBallanceReaming += slotData.opsTeam[j].balanceQuota;

                        }
                    }

                }
                    // remove code for changing balance quota
                if(totalBalanceTeamQuota< slotData.opsGroup.balanceQuota && opsGroupData.length !== 1){
                    slotData.opsGroup.balanceQuota = totalBalanceTeamQuota;
                }
                newFinalData.push(slotData);

            }
            newFinalData.forEach((ite)=>{
               ite.opsGroup.balanceQuota = ite.opsGroup.quota - ite.opsGroup.successful;
            });
            let leaveFormat = 5;
            if (ballotData.leaveConfiguration === 2) {
                leaveFormat = 6;
            } else if (ballotData.leaveConfiguration === 3) {
                leaveFormat = 7;
            }
            let totalTeamUnassign = 0;
            for(let i=0; i<newFinalData.length; i++){
                const opsGroupData = newFinalData[i];
                newFinalData[i].opsGroup.unassignBalanace = 0;

                if(opsGroupData.opsTeam.length>0){
                    for(let j=0; j<opsGroupData.opsTeam.length; j++){
                        const opsTeamData = opsGroupData.opsTeam[j];
                        const opsTeamUser = await OpsTeam.findOne({_id: opsTeamData._id}, {userId:1, _id:0}).lean();
                        const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsTeamUser.userId}}, {ballotLeaveBalanced:1, _id:0}).lean();
                        let teamUnassign = 0;
                        leaveBallanceData.forEach((item)=>{
                            teamUnassign+= Math.floor(item.ballotLeaveBalanced/leaveFormat)
                        });
                        // to get all unassign before result release
                        if(!ballotData.isResultRelease && !ballotData.isConduct){
                            teamUnassign+=  newFinalData[i].opsTeam[j].applied;
                        }
                        newFinalData[i].opsTeam[j].unassignBalanace = teamUnassign;
                        totalTeamUnassign+= teamUnassign;
                        newFinalData[i].opsGroup.unassignBalanace += teamUnassign;
                    }


                }else {
                    // no team
                    const opsTeamUser = await OpsGroup.findOne({_id: opsGroupData.opsGroup.opsId}, {userId:1, _id:0}).lean();
                    const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsTeamUser.userId}}, {ballotLeaveBalanced:1, _id:0}).lean();
                    let teamUnassign = 0;
                    leaveBallanceData.forEach((item)=>{
                        teamUnassign+= Math.floor(item.ballotLeaveBalanced/leaveFormat);
                        console.log("teamAnassignes: ",opsGroupData.opsGroup.opsId,"-",teamUnassign);
                    });
                    newFinalData[i].opsGroup.unassignBalanace = teamUnassign;
                    console.log("tnewFinalData[i].opsGroup.unassignBalanace s: ",opsGroupData.opsGroup.opsId,"-",newFinalData[i].opsGroup.unassignBalanace);
                    totalTeamUnassign+= teamUnassign;
                }
            }
            // if(!ballotData.isResultRelease && !ballotData.isConduct){
            //     totalTeamUnassign+=finalTotalApplied;
            // }
            res.json({success: true, data: newFinalData, finalTotalQuota, finalTotalApplied, finalTotalSuccessful, totalTeamUnassign})
        }

        // }catch (e) {

        //}
    }

    async getBallotDetail(Id, isLast) {
        // try{
        const selectedBallotId = Id;
        const ballotData = await Ballot.findOne({_id: selectedBallotId});
        // for BU
        if (ballotData.userFrom === 2) {
            const wonStaffData = [];
            const wonStaffByBu = this.groupByPro(ballotData.wonStaff, 'buId');
            for (let buId in wonStaffByBu) {
                const wonStaffByBu_Week = this.groupByPro(wonStaffByBu[buId], 'weekNo');
                wonStaffData.push({buId, wonStaffByBu_Week})
            }
            const appliedStaffData = [];
            const appliedStaffDataByBu = this.groupByPro(ballotData.appliedStaff, 'buId');
            for (let buId in appliedStaffDataByBu) {
                const appliedStaffDataByBu_Week = this.groupByPro(appliedStaffDataByBu[buId], 'weekNo');
                appliedStaffData.push({buId1: buId, appliedStaffDataByBu_Week})
            }
            const actualSlotValueByBuArr = [];
            const ballotRoundResult = {
                quota: 0,
                applied: 0,
                successful: 0
            };
            for (let i = 0; i < ballotData.slotCreation.length; i++) {
                const slot = ballotData.slotCreation[i];
                // //console.logs('slot', slot);
                const wonBuStaffArr = wonStaffData.filter((bu) => {
                    return bu.buId == slot.buId;
                });
                const appliedBuStaffArr = appliedStaffData.filter((bu) => {
                    return bu.buId1 == slot.buId;
                });
                let appliedBuStaff = null;
                let wonBuStaff = null;
                if (appliedBuStaffArr.length > 0) {
                    appliedBuStaff = appliedBuStaffArr[0];
                }
                if (wonBuStaffArr.length > 0) {
                    wonBuStaff = wonBuStaffArr[0];
                }
                const actualSlotValueByBu = {
                    buId: slot.buId,
                    weekValue: [],
                    ballotRoundResultBuWise: {
                        quota: 0,
                        applied: 0,
                        successful: 0
                    }
                };
                slot.arr.forEach((item, index) => {
                    const slotValue = item.value;
                    ballotRoundResult.quota = ballotRoundResult.quota + slotValue;
                    actualSlotValueByBu.ballotRoundResultBuWise.quota = actualSlotValueByBu.ballotRoundResultBuWise.quota + slotValue;
                    let appliedValue = 0;
                    if (appliedBuStaff && appliedBuStaff.appliedStaffDataByBu_Week['' + index]) {
                        appliedValue = appliedBuStaff.appliedStaffDataByBu_Week['' + index].length;
                        ballotRoundResult.applied = ballotRoundResult.applied + appliedValue;
                        actualSlotValueByBu.ballotRoundResultBuWise.applied = actualSlotValueByBu.ballotRoundResultBuWise.applied + appliedValue;

                    }


                    let wonValue = 0;
                    if (wonBuStaff && wonBuStaff.wonStaffByBu_Week['' + index]) {
                        wonValue = wonBuStaff.wonStaffByBu_Week['' + index].length;
                        ballotRoundResult.successful = ballotRoundResult.successful + wonValue;
                        actualSlotValueByBu.ballotRoundResultBuWise.successful = actualSlotValueByBu.ballotRoundResultBuWise.successful + wonValue;
                    }

                    actualSlotValueByBu.weekValue.push(`${slotValue}/${appliedValue}/${wonValue}`);

                });
                actualSlotValueByBuArr.push(actualSlotValueByBu)
            }
            res.send({actualSlotValueByBuArr, ballotRoundResult});
        }
        else {
            const wonStaffDataOpsGroup = [];
            const wonStaffByOpsGroup = this.groupByPro(ballotData.wonStaff, 'opsGroupId');
            for (let opsGroupId in wonStaffByOpsGroup) {
                const wonStaffByBu_Week = this.groupByPro(wonStaffByOpsGroup[opsGroupId], 'weekNo');
                wonStaffDataOpsGroup.push({opsGroupId, wonStaffByBu_Week})
            }
            //console.logs('wonStaffDataOpsGroup', JSON.stringify(wonStaffDataOpsGroup));
            const wonStaffDataOpsTeam = [];
            const wonStaffByOpsTeam = this.groupByPro(ballotData.wonStaff, 'opsTeamId');
            for (let opsTeamId in wonStaffByOpsTeam) {
                const opsGroupId = wonStaffByOpsTeam[opsTeamId][0].opsGroupId;
                const wonStaffByBu_Week = this.groupByPro(wonStaffByOpsTeam[opsTeamId], 'weekNo');
                wonStaffDataOpsTeam.push({opsTeamId, opsGroupId, wonStaffByBu_Week})
            }


            const appliedStaffDataOpsGroup = [];
            const appliedStaffDataByOpsGroup = this.groupByPro(ballotData.appliedStaff, 'opsGroupId');
            //console.logs('*******');
            // //console.logs('appliedStaffDataByOpsGroup', JSON.stringify(appliedStaffDataByOpsGroup));
            //console.logs('*******');
            for (let opsGroupId in appliedStaffDataByOpsGroup) {
                const appliedStaffDataByBu_Week = this.groupByPro(appliedStaffDataByOpsGroup[opsGroupId], 'weekNo');
                appliedStaffDataOpsGroup.push({opsGroupId: opsGroupId, appliedStaffDataByBu_Week})
            }
            //console.logs('appliedStaffDataOpsGroup', JSON.stringify(appliedStaffDataOpsGroup));
            //console.logs('*******');
            const appliedStaffDataOpsTeam = [];
            const appliedStaffDataByOpsTeam = this.groupByPro(ballotData.appliedStaff, 'opsTeamId');
            for (let opsTeamId in appliedStaffDataByOpsTeam) {
                const opsGroupId = appliedStaffDataByOpsTeam[opsTeamId][0].opsGroupId;
                const appliedStaffDataByBu_Week = this.groupByPro(appliedStaffDataByOpsTeam[opsTeamId], 'weekNo');
                appliedStaffDataOpsTeam.push({opsTeamId: opsTeamId, opsGroupId, appliedStaffDataByBu_Week})
            }
            //return res.json({appliedStaffDataOpsTeam,wonStaffDataOpsTeam, wonStaffDataOpsGroup, appliedStaffDataOpsGroup, ballotData});
            let finalValue = [];
            let finalValueTeam = [];
            for (let i = 0; i < ballotData.slotCreation.length; i++) {
                const slotObj = ballotData.slotCreation[i];
                if(slotObj.opsTeam.length>0){
                    // //console.logs('appliedStaffDataOpsTeam', appliedStaffDataOpsTeam);
                    const appliedStaffOpsTeamArr = [];
                    appliedStaffDataOpsTeam.forEach((item) => {
                        for (let i = 0; i < slotObj.opsTeam.length; i++) {
                            if (slotObj.opsTeam[i]._id == item.opsTeamId) {
                                appliedStaffOpsTeamArr.push(item);
                            }
                        }
                    });
                    const wonStaffOpsTeamArr = [];
                    wonStaffDataOpsTeam.forEach((item) => {
                        ////console.logs('itemitem', item);
                        for (let i = 0; i < slotObj.opsTeam.length; i++) {
                            // //console.logs('i', i);
                            //console.logs('slotObj.opsTeam[i]', slotObj.opsTeam[i]._id, item.opsTeamId);
                            if (slotObj.opsTeam[i]._id == item.opsTeamId) {
                                //console.logs('hchchchchhc')
                                wonStaffOpsTeamArr.push(item);
                            }
                        }
                    });
                    // //console.logs('wonStaffOpsTeamArr', wonStaffOpsTeamArr.length);
                    const tire1Quota = [];
                    finalValueTeam = [];
                    slotObj.opsTeam.forEach((team, index) => {
                        const teamWiseQuota = {
                            teamQuota: 0,
                            applied: 0,
                            success: 0
                        };
                        const appliedStaffTeamObj = appliedStaffOpsTeamArr.filter((appliedTeam) => {
                            return appliedTeam.opsTeamId == team._id;
                        });

                        const wonStaffTeamObj = wonStaffOpsTeamArr.filter((wonTeam) => {
                            return wonTeam.opsTeamId == team._id;
                        });
                        ////console.logs('wonStaffTeamObj', wonStaffTeamObj);
                        let teamSlotArr = []
                        for (let j = 0; j < ballotData.weekRange.length; j++) {
                            if (index === 0) {
                                tire1Quota.push(parseInt(slotObj.weekRangeSlot['' + j + 'A'].value));
                            }


                            const week = ballotData.weekRange[j];
                            //console.logs('slotObj.weekRangeSlot[\'\' + j + index].value', slotObj.weekRangeSlot['' + j + index].value);
                            const teamQuota = parseInt(slotObj.weekRangeSlot['' + j + index].value);
                            let appliedStaffQuota = 0;
                            let successStaffQuota = 0;
                            if (appliedStaffTeamObj.length > 0 && appliedStaffTeamObj[0].appliedStaffDataByBu_Week['' + j]) {
                                ////console.logs('aa')
                                appliedStaffQuota = appliedStaffTeamObj[0].appliedStaffDataByBu_Week['' + j].length
                            }
                            if (wonStaffTeamObj.length > 0 && wonStaffTeamObj[0].wonStaffByBu_Week['' + j]) {
                                // //console.logs('aa')
                                successStaffQuota = wonStaffTeamObj[0].wonStaffByBu_Week['' + j].length
                            }
                            teamSlotArr.push({teamQuota, appliedStaffQuota, weekNo: j, successStaffQuota});

                        }
                        //tire1Quota
                        let obj = {
                            teamId: team._id,
                            opsGroupId: slotObj.opsGroup.opsId,
                            value: teamSlotArr
                        };
                        /*   obj[''+team._id] = [];
                           obj[''+team._id] = teamSlotArr;
                           obj.tire1Quota = tire1Quota;*/
                        finalValueTeam.push(obj);
                        teamSlotArr = [];
                        if (index === slotObj.opsTeam.length - 1) {
                            for (let k = 0; k < ballotData.weekRange.length; k++) {
                                let totalTeamQuota = 0;
                                let totalTeamSuccess = 0;
                                let totalTeamApplied = 0;
                                slotObj.opsTeam.forEach((insideTeam, indexIndex) => {
                                    //totalTeamQuota = totalTeamQuota + finalValueTeam[indexIndex].value[k].teamQuota;
                                    totalTeamSuccess = totalTeamSuccess + finalValueTeam[indexIndex].value[k].successStaffQuota;
                                    totalTeamApplied = totalTeamApplied + finalValueTeam[indexIndex].value[k].appliedStaffQuota;
                                });
                                //totalTeamQuota = totalTeamQuota + finalValueTeam[indexIndex].value[k].teamQuota;
                                teamSlotArr.push({
                                    teamQuota: tire1Quota[k],
                                    appliedStaffQuota: totalTeamApplied,
                                    weekNo: k,
                                    successStaffQuota: totalTeamSuccess
                                });

                            }
                            obj = {
                                teamId: 'Tier 1',
                                opsGroupId: slotObj.opsGroup.opsId,
                                value: teamSlotArr
                            };
                            finalValueTeam.push(obj);
                        }
                    });

                    finalValue.push(finalValueTeam);

                } else{
                    console.log("call");
                    finalValueTeam = [];
                    const noOpsTeamAppliedDataArr =  appliedStaffDataOpsGroup.filter((item)=>{
                        return item.opsGroupId == slotObj.opsGroup.opsId;
                    });
                    const noOpsTeamWonDataArr =  wonStaffDataOpsGroup.filter((item)=>{
                        return item.opsGroupId == slotObj.opsGroup.opsId;
                    });
                    let obj = {
                        teamId: null,
                        opsGroupId: slotObj.opsGroup.opsId,
                        value: []
                    };
                    let teamSlotArr = [];
                    for(let i=0; i<ballotData.weekRange.length; i++){
                        let teamQuota = parseInt(slotObj.weekRangeSlot[''+i+'A'].value);

                        let appliedStaffQuota = 0;
                        if(noOpsTeamAppliedDataArr && noOpsTeamAppliedDataArr.length>0 && noOpsTeamAppliedDataArr[0].appliedStaffDataByBu_Week[i] && noOpsTeamAppliedDataArr[0].appliedStaffDataByBu_Week[i].length>0) {
                            appliedStaffQuota = noOpsTeamAppliedDataArr[0].appliedStaffDataByBu_Week[i].length;

                        }
                        let successStaffQuota = 0;
                        if(noOpsTeamWonDataArr && noOpsTeamWonDataArr.length && noOpsTeamWonDataArr[0].wonStaffByBu_Week[i] && noOpsTeamWonDataArr[0].wonStaffByBu_Week[i].length>0) {
                            successStaffQuota = noOpsTeamWonDataArr[0].wonStaffByBu_Week[i].length;
                        }
                        teamSlotArr.push({teamQuota, appliedStaffQuota, weekNo: i, successStaffQuota});
                    }
                    obj.value = teamSlotArr;

                    finalValueTeam.push(obj);
                    finalValue.push(finalValueTeam);
                }
            };
            //return res.json({finalValue})
            
            const newFinalData = [];
            let finalTotalApplied = 0;
            let finalTotalQuota = 0;
            let totalTeamQuota = 0 ;
            let finalTotalSuccessful = 0;
            for (let i = 0; i < ballotData.slotCreation.length; i++) {
                const slotData = ballotData.slotCreation[i];
                const opsGroupData = finalValue[i];
                let totalBalanceTeamQuota = 0;
                slotData.opsGroup.balanceQuota = 0;
                slotData.opsGroup.applied = 0;
                slotData.opsGroup.quota = 0;
                slotData.opsGroup.successful = 0;

                for (let j = 0; j < opsGroupData.length; j++) {
                    if (opsGroupData.length - 1 !== j) {
                        slotData.opsTeam[j].balanceQuota = 0;
                        slotData.opsTeam[j].applied = 0;
                        slotData.opsTeam[j].quota = 0;
                        slotData.opsTeam[j].successful = 0;
                    }
                }
                for (let k = 0; k < ballotData.weekRange.length; k++) {
                    let teamQuota = 0;
                    let teamBallanceReaming = 0;
                    for (let j = 0; j < opsGroupData.length; j++) {
                        if (opsGroupData.length - 1 === j) {
                            // for tire 1
                            //slotData.opsTeam[j].isShow = true;
                            if(opsGroupData.length === 1){
                                slotData.opsGroup.applied += opsGroupData[j].value[k].appliedStaffQuota;
                                // slotData.opsGroup.quota +=  opsGroupData[j].value[k].teamQuota;
                                slotData.opsGroup.successful +=  opsGroupData[j].value[k].successStaffQuota;
                            }
                            slotData.weekRangeSlot[''+k+'A'].value =opsGroupData[j].value[k];
                            //console.logs('opsGroupData[j].value[k]', opsGroupData[j].value[k]);
                            finalTotalApplied +=opsGroupData[j].value[k].appliedStaffQuota;
                            finalTotalSuccessful +=opsGroupData[j].value[k].successStaffQuota;
                            slotData.opsGroup.balanceQuota += opsGroupData[j].value[k].teamQuota -  opsGroupData[j].value[k].successStaffQuota ;
                            if(teamBallanceReaming <  slotData.opsGroup.balanceQuota && opsGroupData.length !== 1){
                                slotData.opsGroup.balanceQuota = teamBallanceReaming;
                            }
                            //console.logs('finalTotalQuotafinalTotalQuota', finalTotalQuota, teamQuota, opsGroupData[j].value[k].teamQuota)
                            if(teamQuota<opsGroupData[j].value[k].teamQuota && opsGroupData.length>1){
                                //console.logs("TEAMQUOTA IS: ",teamQuota);
                                finalTotalQuota += teamQuota;
                                slotData.opsGroup.quota += teamQuota;
                            }else {
                                finalTotalQuota += opsGroupData[j].value[k].teamQuota;
                                slotData.opsGroup.quota += opsGroupData[j].value[k].teamQuota;
                            }
                        } else {
                            slotData.opsTeam[j].isShow = true;
                            slotData.weekRangeSlot[''+k+j].value =opsGroupData[j].value[k];
                            slotData.opsTeam[j].balanceQuota += opsGroupData[j].value[k].teamQuota -  opsGroupData[j].value[k].successStaffQuota;
                            slotData.opsTeam[j].applied += opsGroupData[j].value[k].appliedStaffQuota;
                            slotData.opsTeam[j].quota += opsGroupData[j].value[k].teamQuota;
                            teamQuota +=  opsGroupData[j].value[k].teamQuota;
                            totalTeamQuota += slotData.opsTeam[j].quota
                            slotData.opsTeam[j].successful += opsGroupData[j].value[k].successStaffQuota;
                            slotData.opsGroup.applied += opsGroupData[j].value[k].appliedStaffQuota;
                            //slotData.opsGroup.quota +=  opsGroupData[j].value[k].teamQuota;
                            slotData.opsGroup.successful +=  opsGroupData[j].value[k].successStaffQuota;
                        }
                        if (opsGroupData.length - 1 !== j) {
                            totalBalanceTeamQuota += slotData.opsTeam[j].balanceQuota;
                            teamBallanceReaming += slotData.opsTeam[j].balanceQuota;

                        }
                    }

                }
                // remove code for changing balance quota
                /*  if(totalBalanceTeamQuota< slotData.opsGroup.balanceQuota && opsGroupData.length !== 1){
                      slotData.opsGroup.balanceQuota = totalBalanceTeamQuota;
                  }*/
                newFinalData.push(slotData);

            }
            let leaveFormat = 5;
            if (ballotData.leaveConfiguration === 2) {
                leaveFormat = 6;
            } else if (ballotData.leaveConfiguration === 3) {
                leaveFormat = 7;
            }
            let totalTeamUnassign = 0;
            for(let i=0; i<newFinalData.length; i++){
                const opsGroupData = newFinalData[i];
                newFinalData[i].opsGroup.unassignBalanace = 0;

                if(opsGroupData.opsTeam.length>0){
                    for(let j=0; j<opsGroupData.opsTeam.length; j++){
                        const opsTeamData = opsGroupData.opsTeam[j];
                        const opsTeamUser = await OpsTeam.findOne({_id: opsTeamData._id}, {userId:1, _id:0}).lean();
                        const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsTeamUser.userId}}, {ballotLeaveBalanced:1, _id:0}).lean();
                        let teamUnassign = 0;
                        leaveBallanceData.forEach((item)=>{
                            teamUnassign+= Math.floor(item.ballotLeaveBalanced/leaveFormat)
                        });
                        // remove comment
                        if(!ballotData.isResultRelease && !ballotData.isConduct){
                            teamUnassign+=  newFinalData[i].opsTeam[j].applied;
                        }
                        newFinalData[i].opsTeam[j].unassignBalanace = teamUnassign;
                        totalTeamUnassign+= teamUnassign;
                        newFinalData[i].opsGroup.unassignBalanace += teamUnassign;
                    }


                }else {
                    // no team
                    const opsTeamUser = await OpsGroup.findOne({_id: opsGroupData.opsGroup.opsId}, {userId:1, _id:0}).lean();
                    const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsTeamUser.userId}}, {ballotLeaveBalanced:1, _id:0}).lean();
                    let teamUnassign = 0;
                    leaveBallanceData.forEach((item)=>{
                        teamUnassign+= Math.floor(item.ballotLeaveBalanced/leaveFormat)
                    });
                    newFinalData[i].opsGroup.unassignBalanace = teamUnassign;
                    totalTeamUnassign+= teamUnassign;
                }
            }
             // if(!ballotData.isResultRelease && !ballotData.isConduct){
             //     totalTeamUnassign+=finalTotalApplied;
             // }
           return {success: true, data: newFinalData, finalTotalQuota, finalTotalApplied, finalTotalSuccessful, totalTeamUnassign}
        }

        // }catch (e) {

        //}
    }
    async ballotDetailAll(req, res){
        // last round come first
        const ballotId = req.body.selectedBallotId;
        let allData = [];
        let quotaCal = [];
        const len = ballotId.length-1;
        let finalTotalQuota=0, finalTotalApplied=0, finalTotalSuccessful=0, totalTeamUnassign=0;
        for(let i=0; i<ballotId.length; i++){
            if(0 === i){
                const data = await this.getBallotDetail(ballotId[i], true);
                totalTeamUnassign = data.totalTeamUnassign;

                finalTotalQuota = data.finalTotalQuota;
                finalTotalApplied = data.finalTotalApplied;
                finalTotalSuccessful = data.finalTotalSuccessful;
                quotaCal.push({finalTotalQuota, finalTotalSuccessful, finalTotalApplied});
                allData.push(data.data);
            }else {
                const data = await this.getBallotDetail(ballotId[i], false);
                quotaCal.push({finalTotalQuota:data.finalTotalQuota, finalTotalSuccessful:data.finalTotalSuccessful, finalTotalApplied:data.finalTotalApplied});
                finalTotalQuota += data.finalTotalQuota;
                finalTotalApplied += data.finalTotalApplied;
                finalTotalSuccessful += data.finalTotalSuccessful;
                allData.push(data.data);
            }
        }
        let actualData = {};
        for(let i=0; i<allData.length; i++){
            const dataObj = allData[i];
            if(i===0){
                actualData = dataObj;
            }else {
                for(let j=0; j<dataObj.length; j++){
                    const obj = dataObj[j];
                    const weekObj = obj.weekRangeSlot;
                    for (let key in weekObj) {
                        if (weekObj.hasOwnProperty(key)) {
                            //console.logs(key, weekObj[key].value.teamQuota, actualData[j].weekRangeSlot[key].value.teamQuota);
                            actualData[j].weekRangeSlot[key].value.teamQuota = weekObj[key].value.teamQuota;
                            //actualData[j].weekRangeSlot[key].value.teamQuota += weekObj[key].value.teamQuota;
                            actualData[j].weekRangeSlot[key].value.appliedStaffQuota += weekObj[key].value.appliedStaffQuota;
                            actualData[j].weekRangeSlot[key].value.successStaffQuota += weekObj[key].value.successStaffQuota;
                        }
                    }
                }
            }
        }
        quotaCal = quotaCal.reverse();
        let finalQuota = 0;
        let preQuota = 0;
        let preSuccess = 0;
        quotaCal.forEach((item, index)=>{
            if(index === 0){
                finalQuota = item.finalTotalQuota;
                preQuota = item.finalTotalQuota;
                preSuccess =item.finalTotalSuccessful;
            }
            else{

                //finalQuota = finalQuota+(item.finalTotalQuota -preQuota-preSuccess);
                preQuota = item.finalTotalQuota;
                preSuccess =item.finalTotalSuccessful;
            }
        });
        return res.json({success: true, data: actualData, finalTotalQuota:finalQuota, finalTotalApplied, finalTotalSuccessful, totalTeamUnassign});

    }
    async ballotConsolidatedResult(req, res){
        // last round come first
        const ballotId = req.body.selectedBallotId;
        let allData = [];
        let quotaCal = [];
        const len = ballotId.length-1;
        let finalTotalQuota=0, finalTotalApplied=0, finalTotalSuccessful=0, totalTeamUnassign=0;
        for(let i=0; i<ballotId.length; i++){
            if(0 === i){
                const data = await this.getBallotDetail(ballotId[i], true);
                totalTeamUnassign = data.totalTeamUnassign;

                finalTotalQuota = data.finalTotalQuota;
                finalTotalApplied = data.finalTotalApplied;
                finalTotalSuccessful = data.finalTotalSuccessful;
                //console.logs('xxxxxxxxxxxxxxxxxx',finalTotalQuota, finalTotalSuccessful);
                quotaCal.push({finalTotalQuota, finalTotalSuccessful, finalTotalApplied});
                allData.push(data.data);
            }else {
                const data = await this.getBallotDetail(ballotId[i], false);
                quotaCal.push({finalTotalQuota:data.finalTotalQuota, finalTotalSuccessful:data.finalTotalSuccessful, finalTotalApplied:data.finalTotalApplied});
                finalTotalQuota += data.finalTotalQuota;
                finalTotalApplied += data.finalTotalApplied;
                finalTotalSuccessful += data.finalTotalSuccessful;
                allData.push(data.data);
            }
        }
        quotaCal = quotaCal.reverse();
        //return res.json({quotaCal})
        let finalQuota = 0;
        let preQuota = 0;
        let preSuccess = 0;
        quotaCal.forEach((item, index)=>{
            if(index === 0){
                finalQuota = item.finalTotalQuota;
                preQuota = item.finalTotalQuota;
                preSuccess =item.finalTotalSuccessful;
            }
            else{
                //console.logs('finalQuota', finalQuota, item.finalTotalQuota);
                finalQuota = finalQuota+(item.finalTotalQuota -(preQuota- preSuccess));
                preQuota = item.finalTotalQuota;
                preSuccess =preSuccess+ item.finalTotalSuccessful;
            }
        });
        return res.json({success: true,finalTotalQuota:finalQuota, finalTotalSuccess:preSuccess});

    }
    groupByPro(xs, key) {
        return xs.reduce(function (rv, x) {
            (rv[x[key]] = rv[x[key]] || []).push(x);
            return rv;
        }, {});
    }

    async ballotDetailsByUsers(req,res){
        try{
        let ballotId = req.params.id;

        const parentBallot = await Ballot.findOne({_id:ballotId});

        let userList =[];
        if(!parentBallot){
            return res.json({status: false, message: "Coulden't find requested ballot "});
        }else{
            var applied = groupByA(parentBallot.appliedStaff, function(item)
            {
                return [item.userId, item.opsGroupId,item.opsTeamId];
            });
            // var won = groupByA(parentBallot.wonStaff, function(item)
            // {
            //     return [item.userId, item.opsGroupId,item.opsTeamId];
            // });

            var won = groupByAuto(parentBallot.wonStaff, function(item)
            {
                return [item.userId, item.opsGroupId,item.opsTeamId,item.isAutoAssign];
            });
            console.log("autoassignedwon: ",won);
        
            for (var key of applied) {
                let user ={};
                 user.user = await User.findOne({_id:key.userId},{_id:1,name:1,staffId:1});
                 user.Ops = await OpsGroup.findOne({_id:key.opsId},{_id:1,opsGroupName:1});
                if(key.teamId!==null || key.teamId!==undefined){
                user.Team = await OpsTeam.findOne({_id:key.teamId},{_id:1,name:1});
                }else{
                    user.Team={};
                    user.Team.name =' ';
                }
                user.userId = key.userId;
                user.opsId = key.opsId;
                user.teamId = key.teamId;
                user.applied=key.data.length;
                user.ballotId=parentBallot._id;
                user.ballotRound =1;
                user.wonCount = 0;

                userList.push(user);
            }

            for(var ulist of userList){
                for(var wins=0;wins<=won.length-1;wins++){
                    if(ulist.userId==won[wins].userId && ulist.opsId==won[wins].opsId && ulist.teamId==won[wins].teamId && !won[wins].isAuto){
                            ulist.wonCount = won[wins].data.length;
                    }
                    else{
                        //console.logs("not same data here");
                    }
                }
            }
            
            if(parentBallot.childBallots && parentBallot.childBallots.length>0){
                for(let child=0;child<=parentBallot.childBallots.length-1;child++){
                    const childBallot = await Ballot.findOne({_id:parentBallot.childBallots[child]});
                    if(!childBallot){
                        return res.json({status: false, message: "Coulden't find requested ballot "});
                    }else{
                        if(childBallot.isAutoAssign){
                            var won = groupByAuto(childBallot.wonStaff, function(item)
                            {
                                return [item.userId, item.opsGroupId,item.opsTeamId,item.isAutoAssign];
                            });

                            for (var key of won) {
                                let user ={};
                                 user.user = await User.findOne({_id:key.userId},{_id:1,name:1,staffId:1});
                                 user.Ops = await OpsGroup.findOne({_id:key.opsId},{_id:1,opsGroupName:1});
                                if(key.teamId!==null || key.teamId!==undefined){
                                user.Team = await OpsTeam.findOne({_id:key.teamId},{_id:1,name:1});
                                }else{
                                    user.Team={};
                                    user.Team.name =' ';
                                }
                                user.userId = key.userId;
                                user.opsId = key.opsId;
                                user.teamId = key.teamId;
                                user.applied=0;
                                user.ballotId = childBallot._id;
                                user.ballotRound = childBallot.ballotRound+1;
                                user.wonCount = key.data.length;
                                userList.push(user);
                            }
                        
                        }else{
                            var applied = groupByA(childBallot.appliedStaff, function(item)
                            {
                                return [item.userId, item.opsGroupId,item.opsTeamId];
                            });
                            var won = groupByAuto(childBallot.wonStaff, function(item)
                            {
                                return [item.userId, item.opsGroupId,item.opsTeamId,item.isAutoAssign];
                            });
                        
                            for (var key of applied) {
                                let user ={};
                                 user.user = await User.findOne({_id:key.userId},{_id:1,name:1,staffId:1});
                                 user.Ops = await OpsGroup.findOne({_id:key.opsId},{_id:1,opsGroupName:1});
                                if(key.teamId!==null || key.teamId!==undefined){
                                user.Team = await OpsTeam.findOne({_id:key.teamId},{_id:1,name:1});
                                }else{
                                    user.Team={};
                                    user.Team.name =' ';
                                }
                                user.userId = key.userId;
                                user.opsId = key.opsId;
                                user.teamId = key.teamId;
                                user.applied=key.data.length;
                                user.ballotId=childBallot._id;
                                user.ballotRound =childBallot.ballotRound+1;
                                user.wonCount = 0;
                                userList.push(user);
                            }
                
                            for(var ulist of userList){
                                for(var wins=0;wins<=won.length-1;wins++){
                                    if(ulist.userId==won[wins].userId && ulist.opsId==won[wins].opsId && ulist.teamId==won[wins].teamId && !won[wins].isAuto){
                                        ulist.wonCount = won[wins].data.length;
                                    }else{
                                        //console.logs("not same data here");
                                    }
                                }
                            }
                            //console.logs("child yep");
                        }
                      }
                    }
                        
                //console.logs("child yep here nw");
                res.send({userlist:userList});
            }else{
                res.send({userlist:userList});

            }
             //console.logs("sending all at once");
             
           
        }
       }catch(e){
        return res.json({status: false, message: 'Something went wrong', e});
       }

       function groupByA( array , f )
      {
      var groups = {};
       array.forEach( function( o )
      {
        var group = JSON.stringify( f(o) );
   
         groups[group] = groups[group] || [];
    
         groups[group].push( o );  
       });
  
      return Object.keys(groups).map( function( group )
        {
             var array = JSON.parse("[" + group + "]");
              return {userId: array[0][0],opsId:array[0][1], teamId:array[0][2],data:groups[group]}; 
        })
       }



       function groupByAuto( array , f )
       {
       var groups = {};
        array.forEach( function( o )
       {
         var group = JSON.stringify( f(o) );

          groups[group] = groups[group] || [];

          groups[group].push( o );
        });

       return Object.keys(groups).map( function( group )
         {
              var array = JSON.parse("[" + group + "]");
               return {userId: array[0][0],opsId:array[0][1], teamId:array[0][2],isAuto:array[0][3],data:groups[group]};
         })
        }

    }

     async addAsBallotAdmin(req,res){
         try{
            let users=req.body.userIds;
            let user1=await User.updateMany({isBallotAdmin:true},{$set:{isBallotAdmin:false}});
            for(let u=0;u<=users.length-1;u++){
                let id  = users[u].toString();
                //console.logs("USERis: ",id);
                //let user = await User.find({_id: id});
               
               let user = await User.findOneAndUpdate({_id:id},{$set:{isBallotAdmin:true}});
                //console.logs("USers: ",user); 

            }
            return res.json({status:true,message:'Saved Successfully.'});
         }catch(e){
            return res.json({status: false, message: 'Something went wrong', e});
         }
     }

     async getballotAdmins(req,res){
         try{

           let Users = await User.find({isBallotAdmin:true},{_id:1,name:1,staffId:1});
            return res.json({status: true, data:Users , message: 'Users retrieved successfully.'});
         }catch(e){
            return res.json({status: false, message: 'Something went wrong', e});
         }
     }

     async getBallotPerStaffData(req,res){
         let body = req.body;
         //console.logs("UESR ID HERE IS: ",body.userId);
         let ballot = await Ballot.findOne({_id:body.id});
        
         if(!ballot){
            return res.json({status: false, message: 'requested ballot for this user could not found', e});
         }else{
             let resObj={};
             resObj.ballotStartDate = ballot.ballotStartDate;
             resObj.ballotEndDate = ballot.ballotEndDate;
             
             resObj.leaveType =ballot.leaveType;
             resObj.maxConsecutiveBallot = ballot.maxConsecutiveBallot;
             resObj.applicationCloseDateTime = ballot.applicationCloseDateTime;
             resObj.opsGroup = body.opsGroup;

             let applied = ballot.appliedStaff.filter(x=>(x.userId).toString() === (body.userId).toString());
             let won = ballot.wonStaff.filter(x => (x.userId).toString() === (body.userId).toString());
             let winSlots = [];
             if(applied.length>0 && won.length>0){
                for(var a=0;a<=applied.length-1;a++){
                    let slot= applied[a].weekNo;
                    let oneSlot ={};
                    oneSlot.start = ballot.weekRange[slot].start;
                    oneSlot.end = ballot.weekRange[slot].end;
                    oneSlot.weekNo = slot;
                    oneSlot.staffStatus = '';
                    if(ballot.isConduct){
                        //console.logs("INIF");
                        oneSlot.staffStatus = 'Unsuccessful';
                    }
                   
                    for(var w=0;w<=won.length-1;w++){
                        if (applied[a].userId.toString()===won[w].userId.toString() && applied[a].weekNo === won[w].weekNo) {
                                    
                            oneSlot.staffStatus = 'Successful';
                        }
                      
                       
                    }
                    winSlots.push(oneSlot);
                }
             }
             if(ballot.isAutoAssign===true){
                const result = won.filter(staff => staff.isAutoAssign ===true);
                if(result.length>0){
                    for(let r=0;r<=result.length-1;r++){
                        let slot= result[r].weekNo;
                        let oneSlot ={};
                        oneSlot.start = ballot.weekRange[slot].start;
                        oneSlot.end = ballot.weekRange[slot].end;
                        oneSlot.weekNo = slot;
                        oneSlot.staffStatus = 'autoAssigned';
                        winSlots.push(oneSlot);
                    }
                }
             }
             if(applied.length>0 && !won.length>0){
                for(var a=0;a<=applied.length-1;a++){
                    let slot= applied[a].weekNo;
                    let oneSlot ={};
                    oneSlot.start = ballot.weekRange[slot].start;
                    oneSlot.end = ballot.weekRange[slot].end;
                    oneSlot.weekNo = slot;
                    oneSlot.staffStatus = '';
                    if(ballot.isResultRelease){
                        //console.logs("INIF");
                        oneSlot.staffStatus = 'Unsuccessful';
                    }
                    winSlots.push(oneSlot);
                   }
             }
            //  if(won.length>0){
            //      for(var w=0;w<=won.length-1;w++){
            //          let slot= won[w].weekNo;
            //          let oneSlot ={};
            //          oneSlot.start = ballot.weekRange[slot].start;
            //          oneSlot.end = ballot.weekRange[slot].end;
            //          oneSlot.weekNo = slot;
            //          winSlots.push(oneSlot);
            //      }
            //  }
             resObj.won = winSlots;
             return res.json({status:true,data: resObj, message:'successfully retrived ballot data'})
         }
     }
     async cancelBallotAll(req,res){
         let id= req.params.id;
         const updateLeaveBy = [];
         const ballot =await Ballot.findOne({_id:id},{ballotName:1,wonStaff:1,leaveConfiguration:1,childBallots:1,opsGroupId:1,userFrom:1});
         let leaveFormat = 5;
         if (ballot.leaveConfiguration === 2) {
             leaveFormat = 6;
         } else if (ballot.leaveConfiguration === 3) {
             leaveFormat = 7;
         }
        
         if(!ballot){
            return res.json({status:false, message:'Problem receiving ballot id'})
         }
         const wonStaff = groupBy(ballot.wonStaff, 'userId');
         for(var key in wonStaff){
            //console.logs(key, wonStaff[key]);
            let keyP = key;
            
            let keyV = wonStaff[key].length;
            let valueOfKey = leaveFormat*keyV;
            updateLeaveBy.push({key:keyP,leave:valueOfKey,data:wonStaff[key]});
        }
     
         if(ballot.childBallots && ballot.childBallots.length>0){
             //console.logs("IN IF");
             
             for(var i=0;i<=ballot.childBallots.length-1;i++){
                 //console.logs(ballot.childBallots[i])
                 let cid=ballot.childBallots[i];
                const cBallot =await Ballot.findOne({_id:cid},{wonStaff:1,leaveConfiguration:1});
                let cWOn = groupBy(cBallot.wonStaff,'userId');
                for(var keyc in cWOn){
                    //console.logs(keyc, cWOn[keyc]);
                    let keyPP = keyc;
                    let keyVP = cWOn[keyc].length;
                    let valueOfKeyP = leaveFormat*keyVP;
                    updateLeaveBy.push({key:keyPP,leave:valueOfKeyP,data:keyVP});
                }
                
             }


           
         }

         for (let i = 0; i < updateLeaveBy.length; i++) {
            const user = updateLeaveBy[i];
            //console.logs('user', user)
            if (user.leave > 0) {
                const staffLeavedata = await StaffSapData.findOne({staff_Id: user.key});
                if (staffLeavedata) {
                    let totalLeave = staffLeavedata.ballotLeaveBalanced + user.leave;
                    if (totalLeave > staffLeavedata.leavesBalanced) {
                        totalLeave = staffLeavedata.leavesBalanced;
                    }
                    //console.logs("staffLeavedata: ", staffLeavedata);
                    const update = await StaffSapData.update({staff_Id: user.key}, {$set: {ballotLeaveBalanced: totalLeave}});
                }
            }
        }

        const ballotupdate = await Ballot.update({_id: id}, {isCanceled: true});
        for(var i=0;i<=ballot.childBallots.length-1;i++){
            const ballotupdate1 = await Ballot.update({_id: ballot.childBallots[i]}, {isCanceled: true});
        }
        ballotCancelledNotifications(ballot);
        return res.status(201).json({status: true, message: "Ballot Cancelled successfully."});
       
        // return res.json(updateLeaveBy);

               function groupBy(xs, key) {
                    return xs.reduce(function (rv, x) {
                        (rv[x[key]] = rv[x[key]] || []).push(x);
                        return rv;
                    }, {});
                };
      }


       async checkIfHasParent(ballotid){
    
        let currentBallot = await Ballot.findOne({_id:ballotid},{parentBallot:1,childBallots:1});
        if(!currentBallot){
            //console.logs("NO ballot found");
        }else{
            //console.logs("in else of current data found");
            if(currentBallot.parentBallot){
               
                //console.logs("in if of parent data",currentBallot.parentBallot);
                return this.checkIfHasParent(currentBallot.parentBallot)
            }
            if(currentBallot.childBallots && currentBallot.childBallots.length>0){
               
                let list=[];
                list.push(currentBallot._id.toString());
                for(let i=0;i<=currentBallot.childBallots.length-1;i++){
                    list.push(currentBallot.childBallots[i].toString());
                }
               // list=list.concat(currentBallot.childBallots);
                console.log("list s: ",list);
                
                return list;
            }
        }
    }

      async getUserLeavePlans(req,res){
          try{
          
            let user = req.user._id;
            console.log("User:",user);
            let todayIs= new Date();
           
           // const ballotList = await Ballot.find({$or:[{'wonStaff.userId': user}], isPublish: true,isDeleted:false,isResultRelease:true}, {_id:1,ballotName:1,leaveType:1,weekRange:1,wonStaff:1,isCanceled:1,ballotRound:1,isAutoAssign:1,parentBallot:1,childBallots:1});
   
            const allocatedLeaves = await userLeaves.find({userId:user,type:{$in:[1,2,3]},status:{$in:['Allocated','Balloted']}});
            console.log("allocatedLeaves: ",allocatedLeaves);
           const thsUser = await User.findOne({_id:user},{isLeaveSwapAllowed:1,name:1});
           
            let weeksToApply=1;
            let pageSettingData = await PageSettingModel.findOne({
                companyId: req.user.companyId,
                status: 1
            }).select('opsGroup').lean();
            if(pageSettingData.opsGroup.minWeeksBeforeSwop){
                weeksToApply = pageSettingData.opsGroup.minWeeksBeforeSwop;
            }
              let totaldays = weeksToApply*7;
            // ballotList = JSON.stringify(ballotList);
            //ballotList = JSON.parse(ballotList);
            let ballots=[];
             const swopingsFrom = await swopRequests.find({userFrom:req.user._id,requestStatus:1},{requestStatus:1,userFrom:1,leaveFrom:1,leaveTo:1});
            const swopingsTo = await swopRequests.find({userTo:req.user._id,requestStatus:1},{userTo:1,requestStatus:1,leaveFrom:1,leaveTo:1});
             console.log(" const swopingsTo : ",swopingsTo);
           const opsGrp = await OpsGroup.findOne({userId:user,isDelete:false},{swopSetup:1});
           
            if(allocatedLeaves.length>0){
                for(let a=0;a<=allocatedLeaves.length-1;a++){
                    console.log("CAME AGAIN :.....................");
                    let leave={};
                    let from = allocatedLeaves[a].fromdate.split('-');
                    let startdd = new Date(allocatedLeaves[a].fromdate); 
                    from = from[2]+'-'+from[1]+'-'+from[0];
                    let to = allocatedLeaves[a].todate.split('-');
                    let enddd = new Date(allocatedLeaves[a].todate); 
                    to = to[2]+'-'+to[1]+'-'+to[0];
                   
                    var days = Math.floor((enddd - startdd) / (1000*60*60*24));
                    leave.days = days+1;
                    leave.ballotStartDate = allocatedLeaves[a].fromdate;
                    leave.ballotEndDate = allocatedLeaves[a].todate;
                    leave.leaveId = allocatedLeaves[a]._id;
                    if(allocatedLeaves[a].type==1){
                        leave.leaveType = 5;
                    }else{
                        leave.leaveType = allocatedLeaves[a].type;
                    }
                   
                    leave.startdate = startdd;
                    if(opsGrp && opsGrp.swopSetup){
                        
                        leave.swapRequest = parseInt(opsGrp.swopSetup);
                        if(leave.swapRequest ==1 || leave.swapRequest ==2 ){
                                if(thsUser.isLeaveSwapAllowed==true){
                                    leave.swapRequest = 0;
                                    
                                }
                        }
                    }
                    

                    var daysleft = Math.floor((startdd - todayIs) / (1000*60*60*24));
                   
                    daysleft = daysleft+1;
                   
                    
                    if(daysleft < 0 || daysleft<totaldays){
                        
                        leave.swapRequest = 0;
                    }
                   
                    

                    if(swopingsFrom.length>0){
                       
                        //SwoppingFrom means - I have sent this swap request for this slot.
                        let swopping = swopingsFrom.filter(qw=>{
                            if(qw.leaveFrom){
                             
                               return qw.leaveFrom.toString()== allocatedLeaves[a]._id.toString();
                            }else{
                                console.log("OUT");
                            }
                        });
                       
                        if(swopping.length>0){
                           
                            leave.swoppingFrom = true; 
                        }
                    }
                

                    if(swopingsTo.length>0){
                       
                        //SwoppingFrom means - I have sent this swap request for this slot.
                        let swopping = swopingsTo.filter(qw=>{
                            if(qw.leaveTo){
                             
                               return qw.leaveTo.toString()== allocatedLeaves[a]._id.toString();
                            }else{
                                console.log("OUT");
                            }
                        });
                       
                        if(swopping.length>0){
                            leave.swoppingTo = true; 
                            leave.swoppingToCount = swopping.length;
                        }
                    }
                  
                   
                    let leaveAppliedFor = await leaveApplications.find({leaveId:allocatedLeaves[a]._id , userId:req.user._id});
                 
                    if(leaveAppliedFor.length>0){
                        leave.isLeaveApplied = true;
                    }else{
                        leave.isLeaveApplied = false;
                    }
                  
                    ballots.push(leave);
                }
            }

            const BB = ballots.sort((a, b) => b.startdate - a.startdate);
            BB == BB.reverse();
            return res.status(201).json({
                success: true,
                data: BB
            });
           
            
          }catch(e){
            return res.status(500).json({
                success:false,
                data:e,
                message:'Something went wrong'
            });
          }
         
      }

      async exportBallotByUser(req,res){
          let ballotId = req.params.id;
          //console.log("BallotId is: ",ballotId);
          try{
            const parentBallot = await Ballot.findOne({_id:ballotId});
            //console.log("parent Ballot is: ",parentBallot);
           
            let userList =[];
            if(!parentBallot){
                return res.json({status: false, message: "Coulden't find requested ballot "});
            }else{
                let ballotStart = moment(parentBallot.ballotStartDate).format('MM-DD-YYYY');
                let ballotEnd = moment(parentBallot.ballotEndDate).format('MM-DD-YYYY');
                var applied = groupByA(parentBallot.appliedStaff, function(item)
                {
                    return [item.userId, item.opsGroupId,item.opsTeamId];
                });
                var won = groupByA(parentBallot.wonStaff, function(item)
                {
                    return [item.userId, item.opsGroupId,item.opsTeamId];
                });
            
                for (var key of applied) {

                    let user ={};
                     user.user = await User.findOne({_id:key.userId},{_id:1,name:1,staffId:1});
                     user.Ops = await OpsGroup.findOne({_id:key.opsId},{_id:1,opsGroupName:1});
                    if(key.teamId === 'null'|| key.teamId === null || key.teamId===undefined ){
                        user.Team={};
                        user.Team.name =' ';
                    }else{
                        console.log("in team check if");
                        user.Team = await OpsTeam.findOne({_id:key.teamId},{_id:1,name:1});
                        user.teamId = key.teamId;
                    }
                    user.userId = key.userId;
                    user.opsId = key.opsId;
                   // user.teamId = key.teamId;
                    user.applied=key.data.length;
                    user.ballotId=parentBallot._id;
                    user.ballotRound =1;
                    user.wonCount = 0;
                    user.ballotPeriod = ballotStart +' to '+ballotEnd;
                    userList.push(user);
                }
    
                for(var ulist of userList){
                    for(var wins=0;wins<=won.length-1;wins++){
                        if(ulist.userId==won[wins].userId && ulist.opsId==won[wins].opsId && ulist.teamId==won[wins].teamId){
                            ulist.wonCount = won[wins].data.length;
                        }else{
                            //console.logs("not same data here");
                        }
                    }
                }
                
                if(parentBallot.childBallots && parentBallot.childBallots.length>0){
                    for(let child=0;child<=parentBallot.childBallots.length-1;child++){
                        const childBallot = await Ballot.findOne({_id:parentBallot.childBallots[child]});
                        if(!childBallot){
                            return res.json({status: false, message: "Coulden't find requested ballot "});
                        }else{
                            let ballotStartC = moment(childBallot.ballotStartDate).format('MM-DD-YYYY');
                            let ballotEndC = moment(childBallot.ballotEndDate).format('MM-DD-YYYY');
                            var applied = groupByA(childBallot.appliedStaff, function(item)
                            {
                                return [item.userId, item.opsGroupId,item.opsTeamId];
                            });
                            var won = groupByA(childBallot.wonStaff, function(item)
                            {
                                return [item.userId, item.opsGroupId,item.opsTeamId];
                            });
                        
                            for (var key of applied) {

                                let user ={};
                                 user.user = await User.findOne({_id:key.userId},{_id:1,name:1,staffId:1});
                                 user.Ops = await OpsGroup.findOne({_id:key.opsId},{_id:1,opsGroupName:1});
                                 if(key.teamId === 'null'|| key.teamId === null || key.teamId===undefined ){
                                    user.Team={};
                                    user.Team.name =' ';
                                }else{
                                    console.log("in team check if");
                                    user.Team = await OpsTeam.findOne({_id:key.teamId},{_id:1,name:1});
                                    user.teamId = key.teamId;
                                }
                                // if(key.teamId!==null || key.teamId!==undefined){
                                // user.Team = await OpsTeam.findOne({_id:key.teamId},{_id:1,name:1});
                                // }else{
                                //     user.Team={};
                                //     user.Team.name =' ';
                                // }
                                user.userId = key.userId;
                                user.opsId = key.opsId;
                                //user.teamId = key.teamId;
                                user.applied=key.data.length;
                                user.ballotId=childBallot._id;
                                user.ballotRound =childBallot.ballotRound+1;
                                user.wonCount = 0;
                                user.ballotPeriod = ballotStartC +' to '+ballotEndC;
                                userList.push(user);
                            }
                
                            for(var ulist of userList){
                                for(var wins=0;wins<=won.length-1;wins++){
                                    if(ulist.userId==won[wins].userId && ulist.opsId==won[wins].opsId && ulist.teamId==won[wins].teamId){
                                        ulist.wonCount = won[wins].data.length;
                                    }else{
                                        //console.logs("not same data here");
                                    }
                                }
                            }
                            //console.logs("child yep");
                        }
                    }
                    
                    this.sendDetailsDataExport(userList,res);
                }else{
                    this.sendDetailsDataExport(userList,res);
    
                }

                function groupByA( array , f )
                {
                var groups = {};
                 array.forEach( function( o )
                {
                  var group = JSON.stringify( f(o) );
             
                   groups[group] = groups[group] || [];
              
                   groups[group].push( o );  
                 });
            
                return Object.keys(groups).map( function( group )
                  {
                       var array = JSON.parse("[" + group + "]");
                        return {userId: array[0][0],opsId:array[0][1], teamId:array[0][2],data:groups[group]}; 
                  })
                 }

          }
        }catch(e){
            return res.status(500).json({
                success:false,
                data:e,
                message:'Something went wrong'
            });
          }
      }


      async sendDetailsDataExport(results,res){
         
        const csvData = [];
        const keys = [
        'Staff Name',
        'StaffId',
        'Ops Group',
        'Ballot Period',
        'Ballot Round',
        'Submitted Ballots',
        'Successfull Ballots'];
           
            
        results.forEach((item)=>{
            console.log("TEAM HERE : ",item);
            const obj = {};
             obj['Staff Name'] = item.user.name;
             obj['StaffId'] = item.user.staffId;
             obj['Ops Group'] = item.Ops.opsGroupName +" > "+ item.Team.name;
             obj['Ballot Period'] =item.ballotPeriod;
             obj['Ballot Round'] = item.ballotRound;
             obj['Submitted Ballots'] = item.applied;
             obj['Successfull Ballots'] = item.wonCount;
             csvData.push(obj);
             console.log("Data pushed....");
        });
       
        
        json2csv({data: csvData, fields: keys}, function(err, csv) {
            if (err) console.log(err);
           
            res.setHeader('Content-disposition', 'attachment; filename=testing.csv');
            res.set('Content-Type', 'application/csv');
            res.status(200).json({csv, noData: true});
        });
      }


      async saveBallotAsDraft(req, res) {
        try {

            // check required filed
            console.log("REQ OBJ : ",req.body);
            req.body.createdBy = req.user._id;
            req.body.companyId = req.user.companyId;
            const data = req.body;
            if(data.applicationOpenDateTime){
                data.applicationOpenDateTime = moment(data.applicationOpenDateTime, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            }
            if(data.applicationCloseDateTime){
                data.applicationCloseDateTime = moment(data.applicationCloseDateTime, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            }
            if(data.ballotStartDate){
                data.ballotStartDate = moment(data.ballotStartDate, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            }
            if(data.ballotEndDate){
                data.ballotEndDate = moment(data.ballotEndDate, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            }
            if(data.resultRelease && data.resultRelease === '1') {
                data.resultReleaseDateTime = moment(data.resultReleaseDateTime, 'MM-DD-YYYY HH:mm:ss Z').utc().format();
            }
           
               
                         new Ballot(data).save().then((ressss)=>{
                             let message = 'Ballot successfully created';
                             if(data.isDraft){
                                 message = 'Ballot saved as a draft';
                             }else {
                                 //console.log('ressasss', ressss);
                                 // notification for publish ballot
                                // this.sendNotification(ressss)
                             }

                             if(data.parentBallot){
                                 console.log("Parent Ballot is:",data.parentBallot);
                                this.checkIfHasParentAndUpdate(req.body.parentBallot , ressss._id);
                             }
                           return res.json({status: true, message});
                       }).catch((err)=>{
                           console.log('aaaa', err);
                       });

        }catch (e) {
            return res.json({status: false, message: 'Something went wrong1', e});
        }
      }

      async getBallotDataToAutoAssing(req,res){
          try{
            let id = req.params.id;
            const ballot = await Ballot.findOne({_id: id});
            //console.log("BALLOT: ",ballot);
            // let totalQuota=0;
            let slotdata=[];
            let totalTeamUnassign = 0;
            // let leaveFormat = 5;
            // if (ballot.leaveConfiguration === 2) {
            //     leaveFormat = 6;
            // } else if (ballot.leaveConfiguration === 3) {
            //     leaveFormat = 7;
            // }
            if(!ballot){
                return res.json({status: false, message: "Couldn't find requested ballot. ", e});
            }else{
                if(ballot.userFrom===2){
                    //for BU do it later
                }else{
                    let leaveFormat = 5;
                     if (ballot.leaveConfiguration === 2) {
                         leaveFormat = 6;
                     } else if (ballot.leaveConfiguration === 3) {
                         leaveFormat = 7;
                     }

                    //console.log("@ else me once");
                    let newballot = JSON.stringify(ballot);
                    newballot = JSON.parse(newballot);
                    //console.log("@ else me");
                    let slots = ballot.slotCreation;
                    
                    for (let i = 0; i <= slots.length - 1; i++) {
                        let totalQuota=0;
                        let opsGrpid = slots[i].opsGroup.opsId;
                       
                        slots[i].totalBallotBalance = 0;
                      
                        slots[i].opsGroup.unassignBalanace = 0;
                        slots[i].opsGroup.BallotBalance=0;
                        let opsQuota=0;
                        let teamQuota=0;
                        const opsGroupUser = await OpsGroup.findOne({_id: slots[i].opsGroup.opsId}, {userId:1, _id:0}).lean();
                            const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsGroupUser.userId}}, {ballotLeaveBalanced:1, _id:0}).lean();
                            let opsUnassign = 0;
                            leaveBallanceData.forEach((item)=>{
                              //  console.log("inin");
                                opsUnassign+= Math.floor(item.ballotLeaveBalanced/leaveFormat)
                            });
                        slots[i].opsGroup.unassignBalanace = opsUnassign;
                        for (let j = 0; j <= slots[i].arr.length - 1; j++) {
                            let hasTeam=false;
                           // console.log("@inner loop me",slots[i].opsGroup);
                            // let opsQuota=0;
                            // let teamQuota=0;
                            let currentweek = j + 'A';

                            var found = ballot.wonStaff.filter(function (element) {
                                return (element.opsGroupId.toString() === opsGrpid.toString() && element.weekNo === j)
                            });
    
                            slots[i].weekRangeSlot[currentweek].value = slots[i].weekRangeSlot[currentweek].value - found.length;
                            opsQuota = slots[i].weekRangeSlot[currentweek].value;
                            // slots[i].opsGroup.BallotBalance = slots[i].opsGroup.BallotBalance + slots[i].weekRangeSlot[currentweek].value;
                            let currentOpsSlotValueIs = slots[i].weekRangeSlot[currentweek].value;
                            
                            // slots[i].opsGroup.ratioForBalnceQuota = slots[i].opsGroup.unassignBalanace/slots[i].opsGroup.BallotBalance;
                            //Ops Team is there
                            let slotValueOfTeams = 0;
                         
                            if (slots[i].opsTeam.length > 0) {
                                
                                hasTeam=true; 
                                for(let d=0;d<=slots[i].opsTeam.length-1;d++){
                                    slots[i].opsTeam[d].unassignBalanace = 0;
                                    
                                   let currentweek = j + d.toString();
                                    
                                   var found = ballot.wonStaff.filter(function (element) {
                                     
                                       if(element.opsTeamId){
                                       return (element.opsTeamId.toString() === slots[i].opsTeam[d]._id.toString() && element.weekNo === j)
                                       }else{
                                           return (element.opsGroupId===opsGrpid && !element.opsTeamId && element.weekNo===j)
                                       }
   
                                   });
                                  
                                   slots[i].weekRangeSlot[currentweek].value = slots[i].weekRangeSlot[currentweek].value - found.length;

                                   slotValueOfTeams = slotValueOfTeams+slots[i].weekRangeSlot[currentweek].value;

                                   teamQuota=teamQuota+slots[i].weekRangeSlot[currentweek].value ;
                                   if(slots[i].opsTeam[d].BallotBalance){
                                    slots[i].opsTeam[d].BallotBalance = slots[i].opsTeam[d].BallotBalance+slots[i].weekRangeSlot[currentweek].value;

                                   }else{
                                    slots[i].opsTeam[d].BallotBalance = 0;
                                    slots[i].opsTeam[d].BallotBalance = slots[i].opsTeam[d].BallotBalance+slots[i].weekRangeSlot[currentweek].value;

                                   }

                                   //to find Unassigned per team
                                   
                                    const opsTeamUser = await OpsTeam.findOne({_id: slots[i].opsTeam[d]._id}, {userId:1, _id:0}).lean();
                                    const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsTeamUser.userId}}, {ballotLeaveBalanced:1, _id:0}).lean();
                                    let teamUnassign = 0;
                                    leaveBallanceData.forEach((item)=>{
                                        
                                       teamUnassign+= Math.floor(item.ballotLeaveBalanced/leaveFormat)
                                    });
                                   
                                    slots[i].opsTeam[d].unassignBalanace = teamUnassign;
                                    slots[i].opsTeam[d].ratioForBalnceQuota = slots[i].opsTeam[d].unassignBalanace/slots[i].opsTeam[d].BallotBalance;
                                   
                                  
                                }
                               
                            }
                            if(hasTeam){
                                //if has team is true.
                                if(slotValueOfTeams > currentOpsSlotValueIs){
                                    slots[i].opsGroup.BallotBalance = slots[i].opsGroup.BallotBalance + currentOpsSlotValueIs;
                                }else{
                                    slots[i].opsGroup.BallotBalance = slots[i].opsGroup.BallotBalance + slotValueOfTeams;
                                }
                            }else{
                                //if hasteam is false i.e only opsgroup is there.
                                slots[i].opsGroup.BallotBalance = slots[i].opsGroup.BallotBalance + currentOpsSlotValueIs;
                            }

                            slots[i].opsGroup.ratioForBalnceQuota = slots[i].opsGroup.unassignBalanace/slots[i].opsGroup.BallotBalance;
                           
                           
                            
                            if(opsQuota>teamQuota){
                             //   console.log("Hi the total Quota is: ", teamQuota);
                                totalQuota = totalQuota+teamQuota;
                              
                            }else{
                                totalQuota = totalQuota+opsQuota;
                            }
                            if(teamQuota ===0){
                                totalQuota = totalQuota+opsQuota;
                            }
                            slots[i].totalBallotBalance = totalQuota;
                        }
                       
                    }

                    
                    for (let i = 0; i <= slots.length - 1; i++) {
                      //  console.log("After above for are done",slots[i]);
                      slots[i].totalUnassignedIs=0;

                        let opsRatio = slots[i].opsGroup.ratioForBalnceQuota;
                        let totalinAssign = 0;
                        if (slots[i].opsTeam.length > 0) {
                            for(let t=0;t<=slots[i].opsTeam.length-1;t++){
                                totalinAssign = totalinAssign+slots[i].opsTeam[t].unassignBalanace;
                            }
                            if(totalinAssign > slots[i].opsGroup.unassignBalanace){
                                slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+slots[i].opsGroup.unassignBalanace;
    
                            }else{
                                slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+totalinAssign;
    
                            }
                        }else{
                            slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+slots[i].opsGroup.unassignBalanace;
                        }
                        
                        
                        for (let j = 0; j <= slots[i].arr.length - 1; j++) {
                            let currentweek = j + 'A';
                            
                            slots[i].weekRangeSlot[currentweek].balanceToBeAssigned=0;

                            slots[i].weekRangeSlot[currentweek].balanceToBeAssigned = slots[i].weekRangeSlot[currentweek].value * opsRatio;
                            if (slots[i].opsTeam.length > 0) {
                              
                                for(let d=0;d<=slots[i].opsTeam.length-1;d++){
                                    let teamRatio = slots[i].opsTeam[d].ratioForBalnceQuota;
                                    let currentweek = j + d.toString();
                                    slots[i].weekRangeSlot[currentweek].balanceToBeAssigned =0;
                                    slots[i].weekRangeSlot[currentweek].balanceToBeAssigned = slots[i].weekRangeSlot[currentweek].value * teamRatio;
                                }

                            }
                        }
                    }
                   // console.log("sending date here");
                    let data = {slot:slots};
                    return res.status(201).json({status: true, data: data, message: "Received data."});
                }
            }
          }catch(e){
            return res.json({status: false, message: 'Something went wrong1', e});

          }
         
      }

      async getBallotDataToAssignByStaff(req,res){
          try{
            let ballotId = req.params.id;
            const ballot = await Ballot.findOne({_id:ballotId});
            let leaveFormat = 5;
            if (ballot.leaveConfiguration === 2) {
                leaveFormat = 6;
            } else if (ballot.leaveConfiguration === 3) {
                leaveFormat = 7;
            }
            if(!ballot){
                return res.json({status: false, message: "Couldn't find requested ballot. ", e});
            }else{
                console.log("IN ELSE ME: ");
                let newBallot = JSON.stringify(ballot);
                newBallot = JSON.parse(newBallot);
               
                if(ballot.userFrom===2){
                    //for BU do it later

                }else{
                    let slots = newBallot.slotCreation;
                    let users=[];
                    for(var i=0;i<=slots.length-1;i++){
                        console.log("inside of for: ",slots[i].opsGroup);
                       // let weekRange = slots[i].weekRangeSlot;
                      
                        slots[i].opsGroup.Users=[];
                        const opsGroupUser = await OpsGroup.findOne({_id: slots[i].opsGroup.opsId}, {userId:1, _id:0}).lean();
                        const leaveBallanceOpsData = await StaffSapData.find({staff_Id:{$in:opsGroupUser.userId}, ballotLeaveBalanced:{$gt:leaveFormat-1}}, {staff_Id:1,ballotLeaveBalanced:1, _id:0}).lean();
                      
                       
                        if(slots[i].opsTeam.length>0){
                            for(let j=0;j<=slots[i].opsTeam.length-1;j++){
                                slots[i].opsTeam[j].Users=[];
                                const opsTeamUser = await OpsTeam.findOne({_id: slots[i].opsTeam[j]._id}, {userId:1, _id:0}).lean();
                                 const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsTeamUser.userId}, ballotLeaveBalanced:{$gt:leaveFormat-1}}, {staff_Id:1,ballotLeaveBalanced:1, _id:0}).lean();
                                 leaveBallanceData.forEach((item)=>{
                                    console.log("inin");
                                    let user = {opsG:slots[i].opsGroup.opsId, opsT:slots[i].opsTeam[j]._id,teamIndex:j, userId:item.staff_Id,ballotLeaveBalance:parseInt(item.ballotLeaveBalanced/leaveFormat)};
                                    // let user = {opsG:slots[i].opsGroup.opsId, opsT:slots[i].opsTeam[j]._id,teamIndex:j, userId:item.staff_Id,ballotLeaveBalance:parseInt(item.ballotLeaveBalanced/leaveFormat) ,arr:slots[i].arr,weekRange:Object.assign({},slots[i].weekRangeSlot)};
                                    //slots[i].opsTeam[j].Users= leaveBallanceData;

                                    users.push(user);
                                });
                                
                            }
                        }else{
                            leaveBallanceOpsData.forEach((item)=>{
                                console.log("ininelse");
                                let user = {opsG:slots[i].opsGroup.opsId, opsT:null,userId:item.staff_Id,ballotLeaveBalance:parseInt(item.ballotLeaveBalanced/leaveFormat)};
                               // let user = {opsG:slots[i].opsGroup.opsId, opsT:null,userId:item.staff_Id,ballotLeaveBalance:parseInt(item.ballotLeaveBalanced/leaveFormat),arr:slots[i].arr, weekRange:Object.assign({},slots[i].weekRangeSlot)};
                                //slots[i].opsTeam[j].Users= leaveBallanceData;

                                users.push(user);
                            });
                        }
                        
                    }
                    if(users.length>0){
                        for(let u=0;u<=users.length-1;u++){
                            const username = await User.findOne({_id:users[u].userId},{_id:0,name:1,staffId:1,parentBussinessUnitId:1});

                            users[u].name=username.name;
                            users[u].staffId=username.staffId;
                            users[u].parentBu = username.parentBussinessUnitId;
                        }
                        return res.json({status: true, data:users, message: 'Successfully received data.'});
                    }else{
                        //send users as it is
                        return res.json({status: true, data:users, message: 'Successfully received data.'});
                    }
                    //this.checkforUserResrictions(users,newBallot,res);

                }
            }

          }catch(e){
            return res.json({status: false, message: 'Something went wrong1', e});
          }
        
      }

      async checkforUserResrictions(users,newBallot,res){
        try{
         if(users.length>0){
            for(let u=0;u<=users.length-1;u++){
                users[u].wonWeeks=[];
                let deepClone = JSON.parse(JSON.stringify(users[u].weekRange));
                const username = await User.findOne({_id:users[u].userId},{_id:0,name:1,staffId:1,parentBussinessUnitId:1});
               
                users[u].name=username.name;
                users[u].staffId=username.staffId;
                users[u].parentBu = username.parentBussinessUnitId;
                if(users[u].opsT===null){
                    console.log("In if");
                    let filteredData = newBallot.wonStaff.filter(userWon => userWon.userId.toString() === users[u].userId.toString() && userWon.opsGroupId.toString() === users[u].opsG.toString());
                    for(let f=0;f<=filteredData.length-1;f++){
                        console.log("in filter for loop");
                        const weekIs = filteredData[f].weekNo;
                        let opsWeekIs = weekIs+'A';
                        console.log("opsWeekIs: ",opsWeekIs);
                        deepClone[opsWeekIs].isRestrict =true;
                        deepClone[opsWeekIs].isWon=true;

                        //check for consecutive and restrict
                        if(newBallot.maxConsecutiveBallot !== null && newBallot.maxConsecutiveBallot>0){
                            let nextInd = weekIs+newBallot.maxConsecutiveBallot;
                            if(weekIs < newBallot.maxConsecutiveBallot){
                                let prevInd = weekIs-newBallot.maxConsecutiveBallot;
                                if(deepClone[prevInd+'A']){
                                    deepClone[prevInd+'A'].isRestrict =true;
                                }
                                
                            }
                            if(deepClone[nextInd+'A']){
                                deepClone[nextInd+'A'].isRestrict =true;  
                            }
                        }
                    }


                }else{
                    console.log("In else",users[u].userId);
                   let filteredData = newBallot.wonStaff.filter(userWon => userWon.userId.toString() === users[u].userId.toString() && userWon.opsGroupId.toString() === users[u].opsG.toString() && userWon.opsTeamId.toString() === users[u].opsT.toString());
                   for(let f=0;f<=filteredData.length-1;f++){
                    console.log("in filter for loop");
                    const weekIs = filteredData[f].weekNo;
                    let opsWeekIs = weekIs+'A';
                    console.log("opsWeekIs: ",opsWeekIs);
                     deepClone[opsWeekIs].isRestrict =true;
                     deepClone[opsWeekIs].isWon=true;
                        let teamWeekIs = ''+weekIs+users[u].teamIndex;
                        console.log("teamweek: ",teamWeekIs);
                     deepClone[teamWeekIs].isRestrict =true;
                     deepClone[teamWeekIs].isWon=true;

                      //check for consecutive and restrict

                      if(newBallot.maxConsecutiveBallot !== null && newBallot.maxConsecutiveBallot>0){
                        let nextInd = weekIs+newBallot.maxConsecutiveBallot;
                            if(!(weekIs < newBallot.maxConsecutiveBallot)){
                                let prevInd = weekIs- newBallot.maxConsecutiveBallot;
                                if(deepClone[prevInd+'A']){
                                    deepClone[prevInd+'A'].isRestrict =true;
                                    deepClone[''+prevInd+users[u].teamIndex].isRestrict =true;
                                }
                                
                            }

                            if(deepClone[nextInd+'A']){
                                deepClone[nextInd+'A'].isRestrict =true;
                                deepClone[''+nextInd+users[u].teamIndex].isRestrict =true;
                            }

                      }
                  }
                }
                delete users[u].weekRange;
                users[u].deepClone = deepClone;

                if (newBallot.isRestrict) {
                    const staffRestriction = [];
                    newBallot.staffRestriction.forEach((item) => {
                        let isPresent = false;
                        let staffRestrictionObj = {};
                        isPresent = item.userList.some((user) => {
                            ////console.logs('user',user)
                            if (user.id.toString() === users[u].userId.toString()) {
                                staffRestrictionObj = {
                                    "slot": item.slot,
                                    "startDate": item.startDate,
                                    "endDate": new Date(new Date(item.endDate).setDate(new Date(item.endDate).getDate() + 6)),
                                };
                                return true;
                            }
                        });
                        if (isPresent) {
                            const slot = this.getWeekIndex(item.startDate, newBallot.weekRange, 'start');
                            staffRestrictionObj.slotNo = slot;
                            staffRestriction.push(staffRestrictionObj)

                        }
                    });
                   console.log("isRestrict : ",staffRestriction);
                    if(staffRestriction.length>0){
                        for(let r=0;r<=staffRestriction.length-1;r++){
                            if(users[u].opsT===null){
                                const weekIs = staffRestriction[r].slotNo;
                                let opsWeekIs = weekIs+'A';
                                console.log("opsWeekIs: ",opsWeekIs);
                               deepClone[opsWeekIs].isRestrict =true;
                               deepClone[opsWeekIs].isStaffRestricted=true;
                            }
                            else{
                                const weekIs = staffRestriction[r].slotNo;
                                let opsWeekIs = weekIs+'A';
                                 deepClone[opsWeekIs].isRestrict =true;
                                 deepClone[opsWeekIs].isStaffRestricted=true;
                                 let teamWeekIs = ''+weekIs+users[u].teamIndex;
                                 deepClone[teamWeekIs].isRestrict =true;
                                 deepClone[teamWeekIs].isStaffRestricted=true;
                            }
                        }
                    }

                    const segmentRestriction = [];

                    newBallot.maxSegment.forEach((item, index) => {
                        let startSlot = this.getWeekIndex(item.startDate, newBallot.weekRange, 'start');
                        //console.logs('item.endDate', item.endDate);
                        let endSlot = this.getWeekIndex(item.endDate, newBallot.weekRange, 'end');
                        let slotRange = [];
                        for (let i = startSlot; i <= endSlot; i++) {
                            slotRange.push(i);
                        }
                        let segmentRestrictionObj = {
                            startSlot,
                            endSlot,
                            slotRange,
                            maxBallot: item.maxBallot
                        };
                        segmentRestriction.push(segmentRestrictionObj);
                    });

                    console.log("here after segment restrictions: ",segmentRestriction);
                    if(segmentRestriction.length>0){
                        for(let sg = 0;sg<=segmentRestriction.length-1;sg++){
                            let wonFilterd = newBallot.wonStaff.filter(winers => segmentRestriction[sg].slotRange.includes(winers.weekNo)&& winers.userId.toString()===users[u].userId.toString());
                          console.log("CHECK OF USER IDS ", users[u].userId ,"with: ",segmentRestriction[sg].maxBallot,"and: won",wonFilterd.length);
                            if(segmentRestriction[sg].maxBallot === wonFilterd.length){
                                console.log("IN IF OF SEGMENT MATCH: ",users[u].userId, "for ballot:");
                                for(let slot=0;slot<=segmentRestriction[sg].slotRange.length-1;slot++){
                                    let indexAtSegment = segmentRestriction[sg].slotRange[slot];
                                  //  users[u].deepClone[indexAtSegment+'A'].isRestrict =true;
                                    if(users[u].opsT===null){
                                        users[u].deepClone[indexAtSegment+'A'].isRestrict =true;
                                       
                                    }else{
                                        users[u].deepClone[indexAtSegment+'A'].isRestrict =true;
                                        users[u].deepClone[''+indexAtSegment+users[u].teamIndex].isRestrict =true;
                                    }
                                }
                            }
                           
                            else{
                                 if(!wonFilterd.length>0){
                                    var show = segmentRestriction[sg].slotRange[Math.floor(Math.random() * segmentRestriction[sg].slotRange.length)];
                                    users[u].deepClone[show+'A'].isRestrict =true;
                                    if(users[u].opsT!==null){
                                        users[u].deepClone[''+show+users[u].teamIndex].isRestrict =true;
                                    }
                                 }
                                 for(let slot=0;slot<=segmentRestriction[sg].slotRange.length-1;slot++){
                                const weekNo = segmentRestriction[sg].slotRange[slot]+'A';

                                console.log("in segment R: ",weekNo);
                                if(users[u].deepClone[weekNo].isRestrict){

                                    //its consicative so here again check for consecutive 
                                    if(newBallot.maxConsecutiveBallot !== null && newBallot.maxConsecutiveBallot>0){
                      
                                        let nextInd = segmentRestriction[sg].slotRange[slot]+newBallot.maxConsecutiveBallot;
                                        if(segmentRestriction[sg].slotRange[slot] < newBallot.maxConsecutiveBallot){
                                         let prevInd = segmentRestriction[sg].slotRange[slot]-newBallot.maxConsecutiveBallot;
                                        
                                         users[u].deepClone[prevInd+'A'].isRestrict =true;
                                        }
                                        if(users[u].deepClone[nextInd+'A']){
                                            users[u].deepClone[nextInd+'A'].isRestrict =true;
                                        }
                                       
                                        
                                    }

                                }else{
                                    console.log("its not restriced.")
                                }

                                if(users[u].opsT!==null){
                                    const weekNo = ''+segmentRestriction[sg].slotRange[slot]+users[u].teamIndex;
                                   
                                  if(users[u].deepClone[weekNo].isRestrict){

                                    //its consicative so here again check for consecutive 
                                    if(newBallot.maxConsecutiveBallot !== null && newBallot.maxConsecutiveBallot>0){
                      
                                        let nextInd = segmentRestriction[sg].slotRange[slot]+newBallot.maxConsecutiveBallot;
                                        if(segmentRestriction[sg].slotRange[slot] < newBallot.maxConsecutiveBallot){
                                         let prevInd = segmentRestriction[sg].slotRange[slot]-newBallot.maxConsecutiveBallot;
                                        
                                         users[u].deepClone[''+prevInd+users[u].teamIndex].isRestrict =true;
                                        }
                                        if(users[u].deepClone[''+nextInd+users[u].teamIndex]){
                                        users[u].deepClone[''+nextInd+users[u].teamIndex].isRestrict =true;
                                        }
                                    }

                                  }else{
                                    console.log("Team - its not restriced.")
                                 }
                                }

                                 }
                          }
                        }
                    }


                }

                  //finally the only maxConsecutive ballots to check 
                  if(newBallot.maxConsecutiveBallot !== null && newBallot.maxConsecutiveBallot>0){
                    console.log("here at newballot check ia ma");
                let check=checkForIsRestrict(users[u].deepClone);
                console.log("CHeck is: ",check);
                if(check===true){
                  console.log("CHeck is: inside true one ",);
                  for(let ar=0;ar<=users[u].arr.length-1;ar++){
                      //for ops group here
                      console.log(ar);
                     let nextOfar =ar+newBallot.maxConsecutiveBallot;
                     console.log(users[u].deepClone[ar+'A']);

                      //writting random no logic here..
                      const ballarr=[ar,nextOfar];
                      var show = ballarr[Math.floor(Math.random() * ballarr.length)];
                      // console.log("SHOW IS: between ",ar ,"and",nextOfar,"=>",show);

                     if(users[u].deepClone[ar+'A'].isRestrict){
                         console.log("curent index is restricted go to next iteration.");
                     }else{
                         if(users[u].deepClone[nextOfar+'A']){
                          if(users[u].deepClone[nextOfar+'A'].isRestrict){
                              console.log("next on resticted so chill");
                          }else{
                              //users[u].deepClone[nextOfar+'A'].isRestrict = true;
                              users[u].deepClone[show+'A'].isRestrict = true;
                          }
                       }
                     }
                      //For ops teams
                           if(users[u].opsT!==null){
                             
                              if(users[u].deepClone[''+ar+users[u].teamIndex].isRestrict){
                                  console.log("curent index is restricted go to next iteration.");
                              }else{
                                  if(users[u].deepClone[nextOfar+'A']){
                                   if(users[u].deepClone[''+nextOfar+users[u].teamIndex].isRestrict){
                                       console.log("next on resticted so chill");
                                   }else{
                                       //users[u].deepClone[''+nextOfar+users[u].teamIndex].isRestrict = true;
                                       users[u].deepClone[''+show+users[u].teamIndex].isRestrict = true;
                                   }
                                  }
                              }
                           }

                  }
                }else{
                  console.log("In return check else");
                  for(let ar =0;ar<=users[u].arr.length-1;ar++){
                      //for ops group here
                     let nextOfar =ar+newBallot.maxConsecutiveBallot;
                      //writting random no logic here..
                      const ballarr=[ar,nextOfar];
                      var show = ballarr[Math.floor(Math.random() * ballarr.length)];
                      // console.log("SHOW IS: between ",ar ,"and",nextOfar,"=>",show);


                     if(users[u].deepClone[ar+'A'].isRestrict){
                         console.log("curent index is restricted go to next iteration.");
                     }else{
                       if(users[u].deepClone[nextOfar+'A']){
                          if(users[u].deepClone[nextOfar+'A'].isRestrict){
                              console.log("next on resticted so chill");
                          }else{
                              //users[u].deepClone[nextOfar+'A'].isRestrict = true;
                              users[u].deepClone[show+'A'].isRestrict = true;

                          }
                       }
                     }

                      //For ops teams
                      if(users[u].opsT!==null){
                             
                          if(users[u].deepClone[''+ar+users[u].teamIndex].isRestrict){
                              console.log("curent index is restricted go to next iteration.");
                          }else{
                              if(users[u].deepClone[nextOfar+'A']){
                               if(users[u].deepClone[''+nextOfar+users[u].teamIndex].isRestrict){
                                   console.log("next on resticted so chill");
                               }else{
                                 //  users[u].deepClone[''+nextOfar+users[u].teamIndex].isRestrict = true;
                                 users[u].deepClone[''+show+users[u].teamIndex].isRestrict = true;
                               }
                             }
                          }
                       }

                  }
                }
               delete users[u].arr;
              }

               
            }
            
         }else{
             //This case will never happen.In case is happens by mistake We are returning all users list without applying any Restrictions.
         }
        return res.json({status: true, data:users, message: 'Successfully received data.'});
        }catch(e){
            return res.json({status: false, data:e, message: 'cannot receive data.'});
        }

        function checkForIsRestrict(clone){
            
            var cc=false;
            for(let [key, value] of Object.entries(clone)) {
                console.log(key,value);
               
                if(value.isRestrict){
                 // return true;
                 cc=true;
                }else{
                    console.log("no");
                }
              
          }
         
          return cc;
        }
     }

      async getAutoAssignedUsers(req,res){
          try{
           
            const ballotId = req.params.id;
           
            let finalWonStaff = [];
            const ballotData = await Ballot.findById({_id: ballotId},{_id:0,ballotName:1,wonStaff:1});
            let newBallot = JSON.stringify(ballotData);
            newBallot = JSON.parse(newBallot);
          //  const Ballot = await Ballot.findOne({_id:ballotId},{_id:0,ballotName:1,wonStaff:1});
           
            const result = newBallot.wonStaff.filter(staff => staff.isAutoAssign ===true);
           
            if(result.length>0){
                for(let r=0;r<=result.length-1;r++){
                    const user=await User.findOne({_id:result[r].userId},{_id:0,name:1,staffId:1});
                    result[r].userData=user;
                    finalWonStaff.push(result[r]);
                }
            }else{
                finalWonStaff = result;
            }
            // finalWonStaff = result;
            finalWonStaff = groupBy(finalWonStaff, 'userId');

              

                function groupBy(xs, key) {
                    return xs.reduce(function (rv, x) {
                        (rv[x[key]] = rv[x[key]] || []).push(x);
                        return rv;
                    }, {});
                };
            return res.json({message: 'Successfully auto assign done', success: true, finalWonStaff})


          }catch(e){
            return res.status(500).json({status: false, message: 'Something went wrong1', e});
          }
      }

      async ballotDetailsForAutoAssigned(req,res){
          try{
            let ballotId = req.params.id;
            const parentBallot = await Ballot.findOne({_id:ballotId});
            let userList =[];
            if(!parentBallot.isAutoAssign){
                res.status(201).json({status: false, message: 'ballot is not yet AutoAssigned'});
            }
            var won = groupByAuto(parentBallot.wonStaff, function(item)
            {
                return [item.userId, item.opsGroupId,item.opsTeamId,item.isAutoAssign];
            });

                for(var wins=0;wins<=won.length-1;wins++){
                    console.log("WON DATA:for ",won[wins]);
                if(won[wins].isAuto){
                    let user ={};
                    user.user = await User.findOne({_id:won[wins].userId},{_id:1,name:1,staffId:1});
                    user.Ops = await OpsGroup.findOne({_id:won[wins].opsId},{_id:1,opsGroupName:1});
                   if(won[wins].teamId!==null || won[wins].teamId!==undefined){
                   user.Team = await OpsTeam.findOne({_id:won[wins].teamId},{_id:1,name:1});
                   }else{
                       user.Team={};
                       user.Team.name =' ';
                   }
                   user.userId = won[wins].userId;
                   user.opsId = won[wins].opsId;
                   user.teamId = won[wins].teamId;
                   user.ballotId=parentBallot._id;
                   user.applied=0;
                   user.ballotRound =parentBallot.ballotRound+1;
                   user.wonCount = won[wins].data.length;
                   console.log("USERS HERE iS: ",user);
                  userList.push(user);
                 }else{
                     console.log("ITS won in ballot before/ not Autoassugned.")
                 }

                }
                res.status(200).json({status: true, message: 'Successfully got data', data:userList});

          }catch(e){
            return res.status(500).json({status: false, message: 'Something went wrong1', e});
          }

          function groupByAuto( array , f )
          {
          var groups = {};
           array.forEach( function( o )
          {
            var group = JSON.stringify( f(o) );

             groups[group] = groups[group] || [];

             groups[group].push( o );
           });

          return Object.keys(groups).map( function( group )
            {
                 var array = JSON.parse("[" + group + "]");
                  return {userId: array[0][0],opsId:array[0][1], teamId:array[0][2],isAuto:array[0][3],data:groups[group]};
            })
           }
      }

    async exportleavebalance(req, res){
        const appliedStaff = await Ballot.findOne({_id:"5ddba42b6253dc44cbcc1dac"}, {_id:0, appliedStaff:1,opsGroupId:1});
        const userId = [];const opsIds=[];
        appliedStaff.opsGroupId.forEach((item)=>{
            opsIds.push(item);
        });
        const opsD = await OpsGroup.find({_id:{$in:opsIds}},{_id:1,userId:1}).lean();
        for(let j=0;j<=opsD.length-1;j++){

            userId.push(opsD[j].userId);
            console.log("userdata: ",opsD[j].userId.length);
        }
        let IDS =[];
        for(let k=0;k<=userId.length-1;k++){
            IDS=IDS.concat(userId[k]);
        }
        console.log("IDS ARE: ",IDS.length);
        const data =  await StaffSapData.find({staff_Id:{$in: IDS}}, {staff_Id:1, postBallotBalance:1,daysBallotApplied:1,
            ballotLeaveBalanced:1,leavesBalanced:1,leavesAvailed:1,leavesEntitled:1}).populate(
            [{path: 'staff_Id', select: "_id name"}
            ]);
        const findaData = [];
        data.forEach((item)=>{
            const obj = JSON.parse(JSON.stringify(item));
            obj.userId = item.staff_Id._id;
            obj.userName = item.staff_Id.name;
            delete obj.staff_Id;
            findaData.push(obj);
        });
        res.send({findaData})

    }
    async revertBallot(req, res){
        const ballotData = await Ballot.findOne({_id:"5db8f61142053834e4903aee"}, {_id:0, weekRange:1, appliedStaff:1, wonStaff:1, leaveConfiguration:1});
        const finalWonStaff = groupBy(ballotData.wonStaff, 'weekNo');
        const applied = groupBy(ballotData.appliedStaff, 'weekNo');
        const wonStaffIdWeekWise = [];
        const appliedStaffIdWeekwise = [];
        let leave =5;
        if(ballotData.leaveConfiguration ===2){
            leave =6;
        }else if(ballotData.leaveConfiguration === 3){
            leave = 7;
        }
        for(let i=0; i<ballotData.weekRange.length; i++){
            if(finalWonStaff[''+i]){
                const arr = finalWonStaff[''+i];
                const userId = [];
                arr.forEach((item=>{
                    userId.push(item.userId.toString());
                }));
                wonStaffIdWeekWise.push(userId);
            }else {
                wonStaffIdWeekWise.push([])
            }
            if(applied[''+i]){
                const arr = applied[''+i];
                const userId = [];
                arr.forEach((item=>{
                    userId.push(item.userId.toString());
                }));
                appliedStaffIdWeekwise.push(userId);
            }else {
                appliedStaffIdWeekwise.push([])
            }
        }

        const unsuccessfullStaff = [];
        for(let j=0; j<ballotData.weekRange.length; j++){
            const arr1 = appliedStaffIdWeekwise[j];
            const arr2 = wonStaffIdWeekWise[j];
            if(j===0){
                console.log('aaa', arr1, arr2)
            }
            const diffUserId = [];
            arr1.forEach((item)=>{
                if(!arr2.includes(item)){
                    diffUserId.push(item);
                }
            });
            if(diffUserId.length === 0){
                unsuccessfullStaff.push([]);
            }else {
                unsuccessfullStaff.push(diffUserId);
            }
        }
        function groupBy(xs, key) {
            return xs.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };
        for(let i=0; i<ballotData.weekRange.length; i++){
            const userId = unsuccessfullStaff[i];
            if(userId.length>0) {
                const sapData = StaffSapData.updateMany({staff_Id: {$in: userId}}, {$inc: {ballotLeaveBalanced: -leave}}).then((result1) => {
                    console.log(result1)
                });
            }
        }
        res.send({unsuccessfullStaff})
    }

    async BallotDataByUserTestExport(req,res){
        let All=[];
        const BallotR= await Ballot.findOne({_id:"5db8f88242053834e4903b00"});
        var applied = groupByOU(BallotR.appliedStaff, function(item)
        {
            return [item.userId, item.opsGroupId, item.opsTeamId];
        });
        var wons = groupByOU(BallotR.wonStaff, function(item)
        {
            return [item.userId, item.opsGroupId, item.opsTeamId];
        });
        for(let apply=0;apply<=applied.length-1;apply++){
            console.log("applied[apply]: ",applied[apply]);
            const user = await User.findOne({_id:applied[apply].userId},{_id:1,name:1,staffId:1}).populate({
                path: 'parentBussinessUnitId',
                select: "name sectionId",
                populate: {
                    path: 'sectionId',
                    select: 'name departmentId',
                    populate: {
                        path: 'departmentId',
                        select: 'name companyId',
                        populate: {
                            path: 'companyId',
                            select: 'name status'
                        }
                    }
                }
            })
            // .populate(
            //             [{path:'parentBussinessUnitId',select:'name'}]);
            const ops = await OpsGroup.findOne({_id:applied[apply].opsId},{_id:0,opsGroupName:1});
            const team = await OpsTeam.findOne({_id:applied[apply].teamId},{_id:0,name:1});
            console.log("User: ",user);
            let row = {};
            row.name=user.name;
            row.staffId=user.staffId;
            row.parentBussinessUnitId = user.parentBussinessUnitId.sectionId.departmentId.name+" > "+user.parentBussinessUnitId.sectionId.name+" > "+user.parentBussinessUnitId.name;
            row.opsGroupName = ops.opsGroupName;
            if(team!==null){
                row.opsTeamName = team.name;
            }else{
                row.opsTeamName = '';
            }

            row.appliedCount = applied[apply].data.length;
            row.slotSubmitted = [];
            for(let k=0;k<=applied[apply].data.length-1;k++){
                let week = applied[apply].data[k].weekNo+1
                let dates = BallotR.weekRange[applied[apply].data[k].weekNo].start + "to"+BallotR.weekRange[applied[apply].data[k].weekNo].end;
                let slot = 'slot-'+ week +"-> "+dates;
                row.slotSubmitted.push(slot);
            }

            for(let won=0;won<=wons.length-1;won++){
               if(applied[apply].userId === wons[won].userId && applied[apply].opsId === wons[won].opsId && applied[apply].teamId === wons[won].teamId){
                   row.wonCount = wons[won].data.length;
                   row.slotSuccessfull=[];
                   for(let k=0;k<=wons[won].data.length-1;k++){
                    let week = wons[won].data[k].weekNo+1
                    let dates = BallotR.weekRange[wons[won].data[k].weekNo].start + "to"+BallotR.weekRange[wons[won].data[k].weekNo].end;
                    let slot = 'slot-'+ week +"-> "+dates;
                    row.slotSuccessfull.push(slot);

                    row.unSuccessfull=[];
                    let difference = row.slotSubmitted.filter(x => !row.slotSuccessfull.includes(x));
                    row.unSuccessfull.push(difference);
                }

               }
            }
            All.push(row);
        }
       // let data = {applied:applied.length,wins:wons.length}

        return res.json({All});


        function groupByOU( array , f )
        {
          var groups = {};
           array.forEach( function( o )
          {
            var group = JSON.stringify( f(o) );

             groups[group] = groups[group] || [];

             groups[group].push( o );
           });

           return Object.keys(groups).map( function( group )
            {
                 var array = JSON.parse("[" + group + "]");
                  return {userId: array[0][0],opsId:array[0][1], teamId:array[0][2],data:groups[group]};
            })
       }

    }

    async AutoAssignBallot(req, res) {
        let id = req.params.id;
        const ballot = await Ballot.findOne({_id: id}).populate([{
                path:'adminId',
                select:'_id name staffId'
            },{path:'opsGroupId',model:'OpsGroup',select:'_id opsGroupName'}
         ]);
        if (!ballot) {
            return res.status(500).json({success: false, message: 'Requested ballot not found'});
        } else {
            if(ballot.isAutoAssign){
              return res.status(402).json({success: false, message: 'Requested ballot Already Auto assigned.'});
            }
            let newballot = JSON.stringify(ballot);
            newballot = JSON.parse(newballot);
            newballot.parentBallot = ballot._id;
            
            //start with remainng quotas
            let slots = ballot.slotCreation;
            if (newballot.userFrom === 2) {
                //FOr BU's
                for (let i = 0; i <= slots.length - 1; i++) {
                    // let users = [];
                    //const users = await User.find({parentBussinessUnitId : slots[i].buId},{_id:1,name:1});
                    for (let j = 0; j <= slots[i].arr.length - 1; j++) {
                        var found = ballot.wonStaff.filter(function (element) {
                            return (element.buId.toString() === slots[i].buId.toString() && element.weekNo === j)
                        });
                        //console.logs("FOUND: ", found);
                        slots[i].arr[j].value = slots[i].arr[j].value - found.length;

                    }
                    //res.send(users)
                }

            } else {
                //For Ops groups
                for (let i = 0; i <= slots.length - 1; i++) {
                    let opsGrpid = slots[i].opsGroup.opsId;
                    for (let j = 0; j <= slots[i].arr.length - 1; j++) {
                        let currentweek = j + 'A';
                        var found = ballot.wonStaff.filter(function (element) {
                            return (element.opsGroupId.toString() === opsGrpid.toString() && element.weekNo === j)
                        });

                        slots[i].weekRangeSlot[currentweek].value = slots[i].weekRangeSlot[currentweek].value - found.length;
                        if (slots[i].opsTeam.length > 0) {
                            slots[i].opsTeam.forEach((team, d) => {
                                let currentweek = j + d.toString();
                                //console.logs("Current week in Team: ", currentweek);
                                var found = ballot.wonStaff.filter(function (element) {

                                    if(element.opsTeamId){
                                    return (element.opsTeamId.toString() === team._id.toString() && element.weekNo === j)
                                    }else{
                                        return (element.opsGroupId===opsGrpid && !element.opsTeamId && element.weekNO===j)
                                    }

                                });
                                //console.logs("FOUND: ", found);
                                slots[i].weekRangeSlot[currentweek].value = slots[i].weekRangeSlot[currentweek].value - found.length;
                            })
                        }
                    }
                }

            }
            newballot.ballotName = newballot.ballotName + '-AutoAssign'
            newballot.slotCreation = slots;
            newballot.appliedStaff = [];
           // newballot.wonStaff = [];
            newballot.isPublish = false;
            newballot.isDraft = false;
            newballot.isResultRelease = false;
            newballot.isAutoAssign=true;
            newballot.isConduct=false;
            delete newballot._id;
            delete newballot.updatedAt;
            delete newballot.createdAt;
            delete newballot.__v;
            delete newballot.resultReleaseDateTime;
            this.getslotsCalculated(newballot,res);
           //return res.status(201).json({status: true, data: newballot, message: "Received data."});


        }
    }

    async getslotsCalculated(ballot,res){
        console.log("I am inside getSlots ");
        try{
          let slotdata=[];
          let totalTeamUnassign = 0;
          let Ratio=0;
              if(ballot.userFrom===2){
                  //for BU do it later
              }else{
                  let leaveFormat = 5;
                   if (ballot.leaveConfiguration === 2) {
                       leaveFormat = 6;
                   } else if (ballot.leaveConfiguration === 3) {
                       leaveFormat = 7;
                   }

                  let newballot = JSON.stringify(ballot);
                  newballot = JSON.parse(newballot);
                  //console.log("@ else me");
                  let slots = ballot.slotCreation;
                  let totUnAssign=0; let totBQ=0;
                  for (let i = 0; i <= slots.length - 1; i++) {
                      let totalQuota=0;
                      let opsGrpid = slots[i].opsGroup.opsId;
                      slots[i].totalUnassignedIs=0;
                     
                      slots[i].totalBallotBalance = 0;
                    
                      slots[i].opsGroup.unassignBalanace = 0;
                      slots[i].opsGroup.BallotBalance=0;
                      let opsQuota=0;
                      let teamQuota=0;let totalinAssign = 0;
                      const opsGroupUser = await OpsGroup.findOne({_id: slots[i].opsGroup.opsId}, {userId:1, _id:0}).lean();
                          const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsGroupUser.userId}}, {ballotLeaveBalanced:1, _id:0}).lean();
                          let opsUnassign = 0;
                          leaveBallanceData.forEach((item)=>{
                            //  console.log("inin");
                              opsUnassign+= Math.floor(item.ballotLeaveBalanced/leaveFormat)
                          });
                      slots[i].opsGroup.unassignBalanace = opsUnassign;
                      console.log(" slots[i].opsGroup.unassignBalanace: ", slots[i].opsGroup.unassignBalanace);
                      for (let j = 0; j <= slots[i].arr.length - 1; j++) {
                          let hasTeam=false;
                          let currentweek = j + 'A';
                           opsQuota = slots[i].weekRangeSlot[currentweek].value;
                          // slots[i].opsGroup.BallotBalance = slots[i].opsGroup.BallotBalance + slots[i].weekRangeSlot[currentweek].value;
                          let currentOpsSlotValueIs = slots[i].weekRangeSlot[currentweek].value;
                          
                          // slots[i].opsGroup.ratioForBalnceQuota = slots[i].opsGroup.unassignBalanace/slots[i].opsGroup.BallotBalance;
                          //Ops Team is there
                          let slotValueOfTeams = 0;
                          
                          if (slots[i].opsTeam.length > 0) {
                              console.log("slots[i].opsTeam.length > 0")
                              hasTeam=true; 
                              for(let d=0;d<=slots[i].opsTeam.length-1;d++){
                                  slots[i].opsTeam[d].unassignBalanace = 0;

                                  
                                 let currentweek = j + d.toString();
                                  
                                 slotValueOfTeams = slotValueOfTeams + slots[i].weekRangeSlot[currentweek].value;
                                 teamQuota = teamQuota + slots[i].weekRangeSlot[currentweek].value ;
                                 if(slots[i].opsTeam[d].BallotBalance){
                                  slots[i].opsTeam[d].BallotBalance = slots[i].opsTeam[d].BallotBalance + slots[i].weekRangeSlot[currentweek].value;
                                 }else{
                                  slots[i].opsTeam[d].BallotBalance = 0;
                                  slots[i].opsTeam[d].BallotBalance = slots[i].opsTeam[d].BallotBalance + slots[i].weekRangeSlot[currentweek].value;
                                 }

                                 //to find Unassigned per team
                                 
                                  const opsTeamUser = await OpsTeam.findOne({_id: slots[i].opsTeam[d]._id}, {userId:1, _id:0}).lean();
                                  const leaveBallanceData = await StaffSapData.find({staff_Id:{$in:opsTeamUser.userId}}, {ballotLeaveBalanced:1, _id:0}).lean();
                                  let teamUnassign = 0;
                                  leaveBallanceData.forEach((item)=>{
                                     teamUnassign+= Math.floor(item.ballotLeaveBalanced/leaveFormat)
                                  });
                                 
                                  slots[i].opsTeam[d].unassignBalanace = teamUnassign;
                                  console.log("slots[i].opsTeam[d].unassignBalanace  : ",slots[i].opsTeam[d].unassignBalanace);
                                  totalinAssign = totalinAssign+slots[i].opsTeam[d].unassignBalanace;
                                  console.log("totalinAssign : ",totalinAssign);
                                  slots[i].opsTeam[d].ratioForBalnceQuota = slots[i].opsTeam[d].unassignBalanace/slots[i].opsTeam[d].BallotBalance;
                                 console.log(" slots[i].opsTeam[d].ratioForBalnceQuota: ", slots[i].opsTeam[d].ratioForBalnceQuota);
                              }
                             
                          }
                          if(hasTeam){
                              //if has team is true.
                              console.log("IAM inside check of team")
                              if(slotValueOfTeams > currentOpsSlotValueIs){
                                  slots[i].opsGroup.BallotBalance = slots[i].opsGroup.BallotBalance + currentOpsSlotValueIs;
                              }else{
                                  slots[i].opsGroup.BallotBalance = slots[i].opsGroup.BallotBalance + slotValueOfTeams;
                              }
                             
                          }else{
                              //if hasteam is false i.e only opsgroup is there.
                              slots[i].opsGroup.BallotBalance = slots[i].opsGroup.BallotBalance + currentOpsSlotValueIs;

                          }

                          slots[i].opsGroup.ratioForBalnceQuota = slots[i].opsGroup.unassignBalanace/slots[i].opsGroup.BallotBalance;
                         console.log("slots[i].opsGroup.ratioForBalnceQuota : ",slots[i].opsGroup.ratioForBalnceQuota);
                          if(opsQuota>teamQuota){
                           //   console.log("Hi the total Quota is: ", teamQuota);
                              totalQuota = totalQuota+teamQuota;
                            
                          }else{
                            
                              totalQuota = totalQuota+opsQuota;
                          }
                          if(teamQuota ===0){
                              totalQuota = totalQuota+opsQuota;
                          }
                          slots[i].totalBallotBalance = slots[i].opsGroup.BallotBalance;
                          console.log("Total Quota is:  ",totalQuota);
                        console.log("slots[i].totalBallotBalance: ",slots[i].totalBallotBalance);
                      }
                      if(slots[i].opsTeam.length > 0){
                        if(totalinAssign > slots[i].opsGroup.unassignBalanace){
                            slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+slots[i].opsGroup.unassignBalanace;

                          }else{
                            slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+totalinAssign;

                          }
                      }else{
                        slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+slots[i].opsGroup.unassignBalanace;
                      }
                      console.log("TPTA:",totBQ);
                      console.log("before totBQ = totBQ+ slots[i].totalBallotBalance: ", slots[i].totalUnassignedIs);
                      totBQ = totBQ+ slots[i].totalBallotBalance;
                      totUnAssign = totUnAssign+slots[i].totalUnassignedIs;
                      console.log("totUnAssign: ", totUnAssign);
                  }
                  console.log("HERE ME");
                  Ratio = totUnAssign/totBQ;
                  console.log("RATOP IS: ",Ratio);
                  ballot.TotBQ = totBQ;
                  ballot.totUN = totUnAssign;
                  ballot.RATio=Ratio;
                  for (let i = 0; i <= slots.length - 1; i++) {
                    //  console.log("After above for are done",slots[i]);
                 //   slots[i].totalUnassignedIs=0;

                      let opsRatio = slots[i].opsGroup.ratioForBalnceQuota;
                      let totalinAssign = 0;
                    //   if (slots[i].opsTeam.length > 0) {
                    //       for(let t=0;t<=slots[i].opsTeam.length-1;t++){
                    //           totalinAssign = totalinAssign+slots[i].opsTeam[t].unassignBalanace;
                    //       }
                    //       if(totalinAssign > slots[i].opsGroup.unassignBalanace){
                    //           slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+slots[i].opsGroup.unassignBalanace;
  
                    //       }else{
                    //           slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+totalinAssign;
  
                    //       }
                    //   }else{
                    //       slots[i].totalUnassignedIs = slots[i].totalUnassignedIs+slots[i].opsGroup.unassignBalanace;
                    //   }
                      
                      
                      for (let j = 0; j <= slots[i].arr.length - 1; j++) {
                          let currentweek = j + 'A';
                          
                          slots[i].weekRangeSlot[currentweek].balanceToBeAssigned=0;
                          slots[i].weekRangeSlot[currentweek].balanceToBeAssigned = Math.round(slots[i].weekRangeSlot[currentweek].value * ballot.RATio);
                         // slots[i].weekRangeSlot[currentweek].balanceToBeAssigned = slots[i].weekRangeSlot[currentweek].value * opsRatio;
                          if (slots[i].opsTeam.length > 0) {
                            
                              for(let d=0;d<=slots[i].opsTeam.length-1;d++){
                                  let teamRatio = slots[i].opsTeam[d].ratioForBalnceQuota;
                                  let currentweek = j + d.toString();
                                  slots[i].weekRangeSlot[currentweek].balanceToBeAssigned =0;
                                  //slots[i].weekRangeSlot[currentweek].balanceToBeAssigned = slots[i].weekRangeSlot[currentweek].value * teamRatio;
                                  slots[i].weekRangeSlot[currentweek].balanceToBeAssigned = Math.round(slots[i].weekRangeSlot[currentweek].value * ballot.RATio);

                              }

                          }
                      }
                  }
                
                  ballot.wonStaff=[];
                  return res.status(201).json({status: true, data: ballot, message: "Received data."});
              }
          
        }catch(e){
          return res.json({status: false, message: 'Something went wrong1', e});

        }
       
    }

    async getSwapDetailChanges(req,res){
        let reqdata = req.body;
        const ballot = await Ballot.findOne({_id:reqdata.ballotId},{weekRange:1,wonStaff:1});
        let slotDates={start:ballot.weekRange[reqdata.slotNo].start,end:ballot.weekRange[reqdata.slotNo].end};
        const ops = await OpsGroup.findOne({userId:req.user._id,isDelete:false},{opsGroupName:1,swopSetup:1,userId:1})
         .populate({path:'userId',select:'name staffId'});
        if(ops){
            let swopSetup = parseInt(ops.swopSetup);
            let users = [];
            console.log("in ops",ops);
            if(swopSetup==1){
                users = ops.userId;
            }else{
                const opsTeam = await OpsTeam.findOne({userId:req.user._id,isDeleted:false},{userId:1})
                .populate({path:'userId',select:'name staffId'});
                if(opsTeam){
                    users = opsTeam.userId;
                }else{
                    return res.status(300).json({
                        success: false,
                        data: null,
                        message:"Couldn't find ops group data of you."
                    });
                }
            }
            const currentuser = await User.findOne({_id:req.user._id},{_id:0,parentBussinessUnitId:1}).populate(
                {
                    path: "parentBussinessUnitId",
                    select: "name",
                    populate: {
                        path: "sectionId",
                        select: "name",
                        populate: {
                            path: "departmentId",
                            select: "name",
                            populate:{
                                path:"companyId",select:"name"
                            }
                        }
                    }
                }
                )
            let BU= currentuser.parentBussinessUnitId.sectionId.departmentId.companyId.name+" > "+currentuser.parentBussinessUnitId.sectionId.departmentId.name+" > "
            +currentuser.parentBussinessUnitId.sectionId.name+" > "+currentuser.parentBussinessUnitId.name;

            let resObj = {
                Bu : BU,
                opsName: ops.opsGroupName,
                opsGroupId:ops._id,
                type:'Balloted',
                leavedays:5,
                currentdates: slotDates,
                slotNo:reqdata.slotNo,
                users:users,
                ballotId:reqdata.ballotId
            }
            return res.status(201).json({
                success: true,
                data: resObj,
                message:"received!"
            });
        }else{
            return res.status(300).json({
                success: false,
                data: null,
                message:"Couldn't find ops group data of you."
            });
        }
    }

    async getslotswonByUser(req,res){
        const ballot = await Ballot.findOne({_id:req.body.ballotId},{wonStaff:1,weekRange:1});
        if(ballot && ballot.wonStaff.length>0){
            let users = ballot.wonStaff.filter(wq=>wq.userId.toString()==req.body.userId.toString());
            
            let resArr=[];
            for(let i=0;i<=users.length-1;i++){
                let currObj ={};
                currObj.slotNo = users[i].weekNo;
                currObj.start = ballot.weekRange[users[i].weekNo].start;
                currObj.end = ballot.weekRange[users[i].weekNo].end;
                resArr.push(currObj);
            }
            return res.status(201).json({
                success: true,
                data: resArr,
                message:"received!"
            });
        }else{
            return res.status(300).json({
                success: false,
                data: null,
                message:"Couldn't find requested ballots and won users."
            });
        }
    }

    async saveWonsAllAsLeave(wonStaff,weekRange,round,id){
        let leaveObjects=[];
        if(wonStaff.length>0){
            for(let i=0;i<=wonStaff.length-1;i++){
                var leave={};
                leave.ballotId = id;
                leave.slotNo = wonStaff[i].weekNo;
                leave.userId=wonStaff[i].userId;
                leave.status="Balloted";
                leave.type= 1;
                leave.fromdate = weekRange[wonStaff[i].weekNo].start;
                leave.todate = weekRange[wonStaff[i].weekNo].end;
                leave.ballotRound = round+1;
                leaveObjects.push(leave);
            }
            userLeaves.insertMany(leaveObjects).then((docs)=>{
                console.log(docs);
            });
        }
    }

    async saveWonsAllAsLeave(wonStaff,weekRange,round,id){
        let leaveObjects=[];
        if(wonStaff.length>0){
            for(let i=0;i<=wonStaff.length-1;i++){
                var leave={};
                leave.ballotId = id;
                leave.slotNo = wonStaff[i].weekNo;
                leave.userId=wonStaff[i].userId;
                leave.status="Balloted";
                leave.type= 1;
                leave.fromdate = weekRange[wonStaff[i].weekNo].start;
                leave.todate = weekRange[wonStaff[i].weekNo].end;
                leave.ballotRound = round+1;
                leaveObjects.push(leave);
            }
            userLeaves.insertMany(leaveObjects).then((docs)=>{
                console.log(docs);
            });
        }
    }

    async createLeaves(req,res){
        const ballot = await Ballot.findOne({_id:req.body.id});
        let leaveObjects=[];
        if(ballot.wonStaff.length>0){
            for(let i=0;i<=ballot.wonStaff.length-1;i++){
                var leave={};
                leave.ballotId = ballot._id;
                leave.slotNo = ballot.wonStaff[i].weekNo;
                leave.userId=ballot.wonStaff[i].userId;
                leave.status="Balloted";
                leave.type= 1;
                leave.fromdate = ballot.weekRange[ballot.wonStaff[i].weekNo].start;
                leave.todate = ballot.weekRange[ballot.wonStaff[i].weekNo].end;
                leave.ballotRound = ballot.ballotRound+1;
                leaveObjects.push(leave);
            }
            userLeaves.insertMany(leaveObjects).then((docs)=>{
                console.log(docs);
            });
        }
    }

 }

function intersect(a, b) {
    var t;
    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter
    return a.filter(function (e) {
        return b.indexOf(e) > -1;
    });
}

Array.prototype.diff = function (arr2) {
    var ret = [];
    this.sort();
    arr2.sort();
    for (var i = 0; i < this.length; i += 1) {
        if (arr2.indexOf(this[i]) > -1) {
            ret.push(this[i]);
        }
    }
    return ret;
};



setInterval(async () => {
    //console.logs('after 5 sec');
    
    const currentTime = new Date();
    const beforeTime = moment(currentTime).add(-1, 'm').toDate();
    const afterTime = moment(currentTime).add(1, 'm').toDate();
    //console.logs('beforeTime', beforeTime);
    //console.logs('afterTime', afterTime)
    const ballotList = await Ballot.find({
        isDeleted: false, isCanceled: false, isPublish: true, isDraft: false,isConduct:true,resultRelease:1,
        resultReleaseDateTime: {
            $gte: new Date(beforeTime).toISOString(),
            $lte: new Date(afterTime).toISOString()
        }
    });
   
    if (ballotList.length > 0) {
        ////console.logs('found', JSON.stringify(ballotList));
        for (let i = 0; i < ballotList.length; i++) {
            ballotList[i].isResultRelease = true;
            let ballot = await Ballot.findByIdAndUpdate(ballotList[i]._id,{$set:{isResultRelease:true}});
            console.log("AT HERE SAVED");
        }
    }
    

},6000);
/* */
// publish ballot
setInterval(async () => {
    //console.logs('after 5 sec');
    const currentTime = new Date();
    const beforeTime = moment(currentTime).add(-0.5, 'm').toDate();
    const afterTime = moment(currentTime).add(0.5, 'm').toDate();
    //console.logs('beforeTime', beforeTime);
    //console.logs('afterTime', afterTime)
    const ballotList = await Ballot.find({
        isDeleted: false, isCanceled: false, isPublish: false, isDraft: false,
        applicationOpenDateTime: {
            $gte: new Date(beforeTime).toISOString(),
            $lte: new Date(afterTime).toISOString()
        }

    });
    // const ballotList = await Ballot.find({_id:"5d74ca847c90200d4bbd6b5a"});


    ////console.logs('ballot', ballotList);
    if (ballotList.length > 0) {
        ////console.logs('found', JSON.stringify(ballotList));
        for (let i = 0; i < ballotList.length; i++) {
            const item = ballotList[i];
            // get user
            // update ballot ispublish

            if (item.userFrom === 1) {
                // user from ops group
                const userIDArr = await OpsGroup.find({_id: {$in: item.opsGroupId}, isDelete: false}, {
                    userId: 1,
                    _id: 0
                });
                let userId = [];
                userIDArr.forEach((item) => {
                    userId = userId.concat(item.userId)
                });
                //console.logs('userId', userId)
                const unAssignUser = await User.find({_id: {$in: userId}})
                    .select("deviceToken")
                    .lean();
                ////console.logs('user11', JSON.stringify(unAssignUser));
                const usersDeviceTokens = [];
                unAssignUser.forEach((token) => {
                    if (token.deviceToken) {
                        usersDeviceTokens.push(token.deviceToken)
                    }
                });
               
                if (usersDeviceTokens.length > 0) {
                    const pushData = {
                            title: 'New Balloting Exercise',
                            body: '" '+item.ballotName+'" Ballot Available. ',
                            bodyText: item.ballotName + ' ballot created.',
                            bodyTime: [item.applicationCloseDateTime],
                            bodyTimeFormat: ['dd MMM']
                        },
                        collapseKey = item._id; /*unique id for this particular ballot */
                    FCM.push(usersDeviceTokens, pushData, collapseKey);
                }
                const data = await Ballot.update({_id: item._id}, {isPublish: true})
            } else {
                // user from bu
                const userList = await User.find({parentBussinessUnitId: {$in: item.businessUnitId}}, {
                    _id: 0,
                    deviceToken: 1
                });
                const usersDeviceTokens = [];
                userList.forEach((token) => {
                    if (token.deviceToken) {
                        usersDeviceTokens.push(token.deviceToken)
                    }
                });
                
                if (usersDeviceTokens.length > 0) {
                    const pushData = {
                        title: 'New Balloting Exercise',
                        body: '" '+item.ballotName+'" Ballot Available.',
                        bodyText: item.ballotName + ' ballot created.',
                        bodyTime: [item.applicationCloseDateTime],
                        bodyTimeFormat: ['dd MMM']
                        },
                        collapseKey = item._id; /*unique id for this particular ballot */
                    FCM.push(usersDeviceTokens, pushData, collapseKey);
                }
                const data = await Ballot.update({_id: item._id}, {isPublish: true})
            }
        }
    } else {
        //console.logs('ndsssddost found')
    }
}, 60000);

/*setInterval(()=>{
    const currentTime = new Date();
    //console.logs(currentTime)
    currentTime.setHours(0,0,0,0);
    const beforeTime =  moment(currentTime).add(1, 'd').toDate();
    const afterTime = moment(currentTime).add(2, 'd').toDate();
    //console.logs('beforeTime', beforeTime);
    //console.logs('afterTime', afterTime);
}, 5000)*/

async function sendBallotEditNotification(item){
  
    const currentTime = new Date();

    if (item.userFrom === 1) {
        
        const userIDArr = await OpsGroup.find({_id: {$in: item.opsGroupId},isDelete:false}, {userId: 1, _id: 0});
        //console.logs("userIDARR : ",userIDArr);
        let userId = [];
        userIDArr.forEach((item) => {
            userId = userId.concat(item.userId)
        });
        //console.logs('userId', userId)
        const unAssignUser = await User.find({_id: {$in: userId}})
            .select("deviceToken")
            .lean();
        ////console.logs('user11', JSON.stringify(unAssignUser));
        const usersDeviceTokens = [];
        unAssignUser.forEach((token) => {
            if (token.deviceToken) {
                usersDeviceTokens.push(token.deviceToken)
            }
        });
        //console.logs('usersDeviceTokens', usersDeviceTokens);
        if (usersDeviceTokens.length > 0) {
            const pushData = {
                    title: 'Balloting Excercise Updated.',
                    body: 'Balloting Excercise "'  + item.ballotName + '" has been revised, please see the new details.',
                    bodyText: 'Balloting Excercise "' + item.ballotName + '" has been revised, please see the new details.',
                    bodyTime: currentTime,
                    bodyTimeFormat: ['DD-MMM-YYYY HH:mm'],
                   
                },
                collapseKey = item._id; /*unique id for this particular ballot */
            FCM.push(usersDeviceTokens, pushData, collapseKey);
        }
        const data = await Ballot.update({_id: item._id}, {isNotified: 4})
    } else {
        // user from bu
        const userList = await User.find({parentBussinessUnitId: {$in: item.businessUnitId}}, {_id: 0, deviceToken: 1});
        const usersDeviceTokens = [];
        userList.forEach((token) => {
            if (token.deviceToken) {
                usersDeviceTokens.push(token.deviceToken)
            }
        });
        if (usersDeviceTokens.length > 0) {
            const pushData = {
                title: 'Balloting Excercise Updated.',
                body: 'Balloting Excercise "'  + item.ballotName + '" has been revised, please see the new details.',
                bodyText: 'Balloting Excercise "' + item.ballotName + '" has been revised, please see the new details.',
                bodyTime: currentTime,
                bodyTimeFormat: ['DD-MMM-YYYY HH:mm'],
                  
                },
                collapseKey = item._id; /*unique id for this particular ballot */
            FCM.push(usersDeviceTokens, pushData, collapseKey);
        }
        const data = await Ballot.update({_id: item._id}, {isNotified: 4})
    }
}

async function ballotCancelledNotifications(item) {
   
    
    const currentTime = new Date();

    if (item.userFrom === 1) {
        
        const userIDArr = await OpsGroup.find({_id: {$in: item.opsGroupId},isDelete:false}, {userId: 1, _id: 0});
        //console.logs("userIDARR : ",userIDArr);
        let userId = [];
        userIDArr.forEach((item) => {
            userId = userId.concat(item.userId)
        });
        //console.logs('userId', userId)
        const unAssignUser = await User.find({_id: {$in: userId}})
            .select("deviceToken")
            .lean();
        ////console.logs('user11', JSON.stringify(unAssignUser));
        const usersDeviceTokens = [];
        unAssignUser.forEach((token) => {
            if (token.deviceToken) {
                usersDeviceTokens.push(token.deviceToken)
            }
        });
        //console.logs('usersDeviceTokens', usersDeviceTokens);
        if (usersDeviceTokens.length > 0) {
            const pushData = {
                    title: 'Balloting Excercise Cancelled.',
                    body: 'Balloting Excercise "'  + item.ballotName + '" has been Cancelled.',
                    bodyText: 'Balloting Excercise "' + item.ballotName + '" has been Cancelled.',
                    bodyTime: currentTime,
                    bodyTimeFormat: ['DD-MMM-YYYY HH:mm'],
                   
                },
                collapseKey = item._id; /*unique id for this particular ballot */
            FCM.push(usersDeviceTokens, pushData, collapseKey);
        }
        const data = await Ballot.update({_id: item._id}, {isNotified: 4})
    } else {
        // user from bu
        const userList = await User.find({parentBussinessUnitId: {$in: item.businessUnitId}}, {_id: 0, deviceToken: 1});
        const usersDeviceTokens = [];
        userList.forEach((token) => {
            if (token.deviceToken) {
                usersDeviceTokens.push(token.deviceToken)
            }
        });
        if (usersDeviceTokens.length > 0) {
            const pushData = {
                    title: 'Ballot Cancelled',
                    body: 'Ballot' + item.ballotName + 'has been Cancelled.',
                    bodyText: 'Ballot' + item.ballotName + 'has been Cancelled.',
                    bodyTime: currentTime,
                    bodyTimeFormat: ['DD-MMM-YYYY HH:mm'],
                  
                },
                collapseKey = item._id; /*unique id for this particular ballot */
            FCM.push(usersDeviceTokens, pushData, collapseKey);
        }
        const data = await Ballot.update({_id: item._id}, {isNotified: 4})
    }
}

async function ballotExtendNotifications(item) {
    const currentTime = new Date();
    if (item.userFrom === 1) {
        // user from ops group
        const userIDArr = await OpsGroup.find({_id: {$in: item.opsGroupId},isDelete:false}, {userId: 1, _id: 0});
        let userId = [];
        userIDArr.forEach((item) => {
            userId = userId.concat(item.userId)
        });
        //console.logs('userId', userId)
        const unAssignUser = await User.find({_id: {$in: userId}})
            .select("deviceToken")
            .lean();
        ////console.logs('user11', JSON.stringify(unAssignUser));
        const usersDeviceTokens = [];
        unAssignUser.forEach((token) => {
            if (token.deviceToken) {
                usersDeviceTokens.push(token.deviceToken)
            }
        });
        //console.logs('usersDeviceTokens', usersDeviceTokens);
        if (usersDeviceTokens.length > 0) {
            const pushData = {
                    title: 'Balloting Excercise Extended',
                    body: 'Closing date of Balloting Excercise "'+ item.ballotName +'" has been extended. Please check the new closing date.',
                    bodyText: 'Closing date of Balloting Excercise "'+ item.ballotName +'" has been extended. Please check the new closing date.',
                    bodyTime: currentTime,
                    bodyTimeFormat: ['DD-MMM-YYYY HH:mm'],
                   
                },
                collapseKey = item._id; /*unique id for this particular ballot */
            FCM.push(usersDeviceTokens, pushData, collapseKey);
        }
        const data = await Ballot.update({_id: item._id}, {isNotified: 3})
    } else {
        // user from bu
        const userList = await User.find({parentBussinessUnitId: {$in: item.businessUnitId}}, {_id: 0, deviceToken: 1});
        const usersDeviceTokens = [];
        userList.forEach((token) => {
            if (token.deviceToken) {
                usersDeviceTokens.push(token.deviceToken)
            }
        });
        if (usersDeviceTokens.length > 0) {
            const pushData = {
                    title: 'Ballot Extended',
                    body: 'Ballot Application date is extended.',
                    bodyText: 'Applocation closing date for  Ballot: ' + item.ballotName + 'is extended.',
                    bodyTime: currentTime,
                    bodyTimeFormat: ['DD-MMM-YYYY HH:mm'],
                   
                },
                collapseKey = item._id; /*unique id for this particular ballot */
            FCM.push(usersDeviceTokens, pushData, collapseKey);
        }
        const data = await Ballot.update({_id: item._id}, {isNotified: 3})
    }
}

async function ballotNotificationBefore2Days() {
    console.log('caleed before 2');
    //console.logs('after 1 hr');
    const currentTime = new Date();
    //console.logs(currentTime)
    currentTime.setHours(0, 0, 0, 0);
    const beforeTime = moment(currentTime).add(2, 'd').toDate();
    const afterTime = moment(currentTime).add(4, 'd').toDate();
    const ddd = new Date('2019-10-28 12:30:00.000Z');
    console.log('beforeTime', beforeTime, 'aaaa', new Date(beforeTime).toISOString());
    console.log('afterTime', afterTime, 'bbbb', new Date(afterTime).toISOString());
    console.log('aaaa', ddd)
    /*, isNotified:0,
        applicationCloseDateTime: {
            $gte: new Date(beforeTime).toISOString(),
            $lte: new Date(afterTime).toISOString()
        }*/
    const ballotList = await Ballot.find({
        isDeleted: false, isCanceled: false, isDraft: false,
        isNotified:0,
        applicationCloseDateTime: {
            $gte: new Date(beforeTime).toISOString(),
            $lte: new Date(afterTime).toISOString()
        }

    });
    // const ballotList = await Ballot.find({_id:"5d74ca847c90200d4bbd6b5a"});


    console.log('ballot 2 days bofore', ballotList.length);
    if (ballotList.length > 0) {
        ////console.logs('found', JSON.stringify(ballotList));
        for (let i = 0; i < ballotList.length; i++) {
            const item = ballotList[i];
            console.log('item ballot 2 days bofore', item.ballotName);
            // get user
            // update ballot ispublish

            if (item.userFrom === 1) {
                // user from ops group
                const userIDArr = await OpsGroup.find({_id: {$in: item.opsGroupId}, isDelete: false}, {
                    userId: 1,
                    _id: 0
                });
                let userId = [];
                userIDArr.forEach((item) => {
                    userId = userId.concat(item.userId)
                });
                //console.logs('userId', userId)
                const unAssignUser = await User.find({_id: {$in: userId}})
                    .select("deviceToken")
                    .lean();
                ////console.logs('user11', JSON.stringify(unAssignUser));
                const usersDeviceTokens = [];
                unAssignUser.forEach((token) => {
                    if (token.deviceToken) {
                        usersDeviceTokens.push(token.deviceToken)
                    }
                });
                //console.logs('usersDeviceTokens', usersDeviceTokens);
                if (usersDeviceTokens.length > 0) {
                    const pushData = {
                            title: 'Reminder on the Balloting Exercise',
                            body: 'Just 2 days left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'Please Ballot in 2 days before it closes.',
                            bodyText: 'Just 2 days left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'Please Ballot in 2 days before it closes.',
                            bodyTime: [item.applicationCloseDateTime],
                            bodyTimeFormat: ['DD-MMM-YYYY HH:mm']
                        },
                        collapseKey = item._id; /*unique id for this particular ballot */
                    FCM.push(usersDeviceTokens, pushData, collapseKey);
                }
                const data = await Ballot.update({_id: item._id}, {isNotified: 1})
            } else {
                // user from bu
                const userList = await User.find({parentBussinessUnitId: {$in: item.businessUnitId}}, {
                    _id: 0,
                    deviceToken: 1
                });
                const usersDeviceTokens = [];
                userList.forEach((token) => {
                    if (token.deviceToken) {
                        usersDeviceTokens.push(token.deviceToken)
                    }
                });
                if (usersDeviceTokens.length > 0) {
                    const pushData = {
                            title: 'Reminder on the Balloting Exercise',
                            body: 'Just 2 days left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'Please Ballot in 2 days before it closes.',
                            bodyText: 'Just 2 days left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'Please Ballot in 2 days before it closes.',
                            bodyTime: [item.applicationCloseDateTime],
                            bodyTimeFormat: ['DD-MMM-YYYY HH:mm']
                        },
                        collapseKey = item._id; /*unique id for this particular ballot */
                    FCM.push(usersDeviceTokens, pushData, collapseKey);
                }
                const data = await Ballot.update({_id: item._id}, {isNotified: 1})
            }
        }
    } else {
        //console.logs('ndsssddost found')
    }
}

async function ballotNotificationBefore1Day() {
    //console.logs('caleesdfddgfdd');
    //console.logs('after 1 hr');
    const currentTime = new Date();
    //console.logs(currentTime)
    currentTime.setHours(0, 0, 0, 0);
    const beforeTime = moment(currentTime).add(1, 'd').toDate();
    const afterTime = moment(currentTime).add(3, 'd').toDate();
    //console.logs('beforeTime', beforeTime);
    //console.logs('afterTime', afterTime);
    const ballotList = await Ballot.find({
        isDeleted: false, isCanceled: false, isNotified:1, isDraft: false,
        applicationCloseDateTime: {
            $gte: new Date(beforeTime).toISOString(),
            $lte: new Date(afterTime).toISOString()
        }

    });
    // const ballotList = await Ballot.find({_id:"5d74ca847c90200d4bbd6b5a"});


    ////console.logs('ballot', ballotList);
    if (ballotList.length > 0) {
        ////console.logs('found', JSON.stringify(ballotList));
        for (let i = 0; i < ballotList.length; i++) {
            const item = ballotList[i];
            // get user
            // update ballot ispublish

            if (item.userFrom === 1) {
                // user from ops group
                const userIDArr = await OpsGroup.find({_id: {$in: item.opsGroupId}, isDelete: false}, {
                    userId: 1,
                    _id: 0
                });
                let userId = [];
                userIDArr.forEach((item) => {
                    userId = userId.concat(item.userId)
                });
                //console.logs('userId', userId)
                const unAssignUser = await User.find({_id: {$in: userId}})
                    .select("deviceToken")
                    .lean();
                ////console.logs('user11', JSON.stringify(unAssignUser));
                const usersDeviceTokens = [];
                unAssignUser.forEach((token) => {
                    if (token.deviceToken) {
                        usersDeviceTokens.push(token.deviceToken)
                    }
                });
                //console.logs('usersDeviceTokens', usersDeviceTokens);
                if (usersDeviceTokens.length > 0) {
                    const pushData = {
                            title: 'Reminder on the Balloting Exercise',
                            body: 'Just a day left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'Please ballot before it closes.',
                            bodyText: 'Just a day left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'Please ballot before it closes.',
                            bodyTime: [item.applicationCloseDateTime],
                            bodyTimeFormat: ['DD-MMM-YYYY HH:mm']
                        },
                        collapseKey = item._id; /*unique id for this particular ballot */
                    FCM.push(usersDeviceTokens, pushData, collapseKey);
                }
                const data = await Ballot.update({_id: item._id}, {isNotified: 2})
            } else {
                // user from bu
                const userList = await User.find({parentBussinessUnitId: {$in: item.businessUnitId}}, {
                    _id: 0,
                    deviceToken: 1
                });
                const usersDeviceTokens = [];
                userList.forEach((token) => {
                    if (token.deviceToken) {
                        usersDeviceTokens.push(token.deviceToken)
                    }
                });
                if (usersDeviceTokens.length > 0) {
                    const pushData = {
                            title: 'Reminder on the Balloting Exercise',
                            body: 'Just a day left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'Please ballot before it closes.',
                            bodyText: 'Just a day left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'Please ballot before it closes.',
                            bodyTime: [item.applicationCloseDateTime],
                            bodyTimeFormat: ['DD-MMM-YYYY HH:mm']
                        },
                        collapseKey = item._id; /*unique id for this particular ballot */
                    FCM.push(usersDeviceTokens, pushData, collapseKey);
                }
                const data = await Ballot.update({_id: item._id}, {isNotified: 2})
            }
        }
    } else {
        //console.logs('ndsssddost found')
    }
}

async function conductBallot(id) {
    try {
        //console.logs("CONDUCT BALLOT HERE......");
        const ballotId = id;
        //console.logs('ballotId', ballotId)
        let ballotResult = await Ballot.findOne({_id: ballotId, isConduct: false});
        if (ballotResult) {
            // result for BU
            if (ballotResult.userFrom === 2) {
                ballotResult = JSON.stringify(ballotResult);
                ballotResult = JSON.parse(ballotResult);
                ////console.logs('ballotResult', ballotResult);
                let shuffle = [];
                shuffle = ballotResult.slotCreation;
                ballotResult.appliedStaff.forEach((appliedStaff) => {
                    const indexOfBu = ballotResult.slotCreation.findIndex(x => x.buId === appliedStaff.buId);
                    if (shuffle[indexOfBu].arr[appliedStaff.weekNo].appliedStaff) {
                        shuffle[indexOfBu].arr[appliedStaff.weekNo].appliedStaff.push(appliedStaff);
                    } else {
                        shuffle[indexOfBu].arr[appliedStaff.weekNo].appliedStaff = [];
                        shuffle[indexOfBu].arr[appliedStaff.weekNo].appliedStaff.push(appliedStaff);
                    }

                });
                let finalWinStaff = [];
                shuffle.forEach((staffShuffle) => {
                    staffShuffle.arr.forEach((slotWise) => {
                        const howMuchWin = slotWise.value;

                        if (slotWise.appliedStaff && slotWise.appliedStaff.length <= howMuchWin) {
                            finalWinStaff = finalWinStaff.concat(slotWise.appliedStaff);
                        } else if (slotWise.appliedStaff) {
                            const randomStaff = getRandomNumber(slotWise.appliedStaff.length, howMuchWin);
                            randomStaff.forEach((randomSelectedStaff) => {
                                finalWinStaff.push(slotWise.appliedStaff[randomSelectedStaff])
                            });
                            //console.logs('slotWise.appliedStaff.length', slotWise.appliedStaff.length, howMuchWin, randomStaff)
                        }
                    });
                });
                const updateWin = await Ballot.findOneAndUpdate({_id: ballotId}, {
                    $set: {
                        wonStaff: finalWinStaff,
                        isConduct: true,
                        isResultRelease: false
                    }
                });
                unSuccessfullStaffLeaveBallotBalanaceUpdate(ballotId);
            } else {
                // for ops group
                ballotResult = JSON.stringify(ballotResult);
                ballotResult = JSON.parse(ballotResult);
                ////console.logs('ballotResult', ballotResult);
                let shuffle = [];

                const opsGroupQuota = [];
                shuffle = ballotResult.slotCreation;
                let appliedStaffArray = [];
                for (let i = 0; i < ballotResult.slotCreation.length; i++) {

                    const opsGroupSlot = ballotResult.slotCreation[i];
                    // get quato for ops group
                    // get quato for team
                    let slotValue = {
                        opsGroupId: opsGroupSlot.opsGroup.opsId,
                        slotQuota: []
                    };
                    opsGroupSlot.arr.forEach((arrItem, arrIndex) => {
                        ////console.logs('aaaaaaaa');
                        let key = '' + arrIndex + 'A';
                        let slotNumber = arrIndex;
                        let slotOpsGroupValue = parseInt(opsGroupSlot.weekRangeSlot[key].value);
                        //opsGroupQuato.push({value:opsGroupSlot.weekRangeSlot[key].value, key});
                        const teamValue = [];
                        let totalTeamQuota = 0;
                        opsGroupSlot.opsTeam.forEach((teamItem, teamIndex) => {
                            ////console.logs('aaaaaaaa');
                            let key = '' + arrIndex + teamIndex;
                            totalTeamQuota = totalTeamQuota + parseInt(opsGroupSlot.weekRangeSlot[key].value);
                            teamValue.push(parseInt(opsGroupSlot.weekRangeSlot[key].value))

                        });
                        const obj = {
                            slot: slotNumber,
                            opsGroupQuotaValue: slotOpsGroupValue,
                            opsTeamQuotaValue: teamValue,
                            totalTeamQuota
                        };
                        slotValue.slotQuota.push(obj);
                    });
                    ////console.logs('aauued', slotValue)
                    opsGroupQuota.push(slotValue)
                    ////console.logs('yyegwb');
                    ////console.logs('aaaa', groupBy(ballotResult.appliedStaff,'weekNo'));
                    let appliedStaffObject = {};
                    appliedStaffObject = groupBy(ballotResult.appliedStaff, 'opsTeamId');
                    ////console.logs('appliedStaffObject', appliedStaffObject)
                    //return res.send(ballotResult.appliedStaff)
                    /* for(let keyyy in appliedStaffObject){
                         const ayaya = groupBy(appliedStaffObject[keyyy],'weekNo');
                         appliedStaffArray.push(ayaya);
                     }*/
                    const opsGroupSlotWithTeam = {
                        opsGroupId: opsGroupSlot.opsGroup.opsId,
                        opsTeamValue: []
                    };
                    //console.logs('yyegwbaaa',opsGroupSlot.opsTeam);
                    if (opsGroupSlot.opsTeam && opsGroupSlot.opsTeam.length > 0) {
                        opsGroupSlot.opsTeam.forEach((teamItem, teamIndex) => {
                            if (appliedStaffObject[teamItem._id]) {
                                const ayaya = groupBy(appliedStaffObject[teamItem._id], 'weekNo');
                                opsGroupSlotWithTeam.opsTeamValue.push(ayaya);
                            }

                        });
                    } else {
                        //console.logs('no temmmm',appliedStaffObject);
                        if(isEmpty(appliedStaffObject)) {
                            // Object is empty (Would return true in this example)
                            //console.logs("do nothing obect is empty");
                        } else {
                            // Object is NOT empty
                            if(appliedStaffObject['undefined']){
                            const staffAyaya = appliedStaffObject['undefined'].filter((sta)=>{
                                return sta.opsGroupId.toString() === opsGroupSlot.opsGroup.opsId.toString()
                            });
                            appliedStaffObject['undefined'] = [];
                            appliedStaffObject['undefined'] = staffAyaya;
                            const ayaya = groupBy(appliedStaffObject['undefined'], 'weekNo');
                            opsGroupSlotWithTeam.opsTeamValue.push(ayaya);
                        }
                            //console.logs("please check here");
                        }
                       
                    }
                    ////console.logs('hgfgetgt')
                    appliedStaffArray.push(opsGroupSlotWithTeam);
                    /*groupBy(ballotResult.appliedStaff, function(item)
                    {
                        return [item.weekNo, item.opsTeamId];
                    });*/

                }
                function isEmpty(obj) {
                    for(var key in obj) {
                        if(obj.hasOwnProperty(key))
                            return false;
                    }
                    return true;
                }
                ////console.logs('aaaaaaaa');
                function groupBy(xs, key) {
                    return xs.reduce(function (rv, x) {
                        (rv[x[key]] = rv[x[key]] || []).push(x);
                        return rv;
                    }, {});
                };

                
                /* function groupBy( array , f )
                 {
                     var groups = {};
                     array.forEach( function( o )
                     {
                         var group = JSON.stringify( f(o) );
                         groups[group] = groups[group] || [];
                         groups[group].push( o );
                     });
                     return Object.keys(groups).map( function( group )
                     {
                         return groups[group];
                     })
                 }*/

                let limitQuota = [];
                let finalWinStaff = [];
                ////console.logs('aaaaaaaa');
                opsGroupQuota.forEach((item, topIndex) => {
                    ////console.logs('aaa')
                    let objA = {
                        opsGroupId: item.opsGroupId,
                    };
                    item.slotQuota.forEach((slll) => {
                        objA.slot = slll.slot;
                        if (slll.opsTeamQuotaValue.length === 0) {
                            objA.isTeamPresent = false;
                            objA.opsGroupQuotaValue = slll.opsGroupQuotaValue;
                            // //console.logs('callleddd');
                            if (appliedStaffArray[topIndex].opsTeamValue[0] && appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot]) {
                                if (slll.opsGroupQuotaValue >= appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot].length) {
                                    finalWinStaff = finalWinStaff.concat(appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot])

                                } else {
                                    const randomStaff = getRandomNumber(appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot].length, slll.opsGroupQuotaValue);
                                    randomStaff.forEach((ppp) => {
                                        finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[0]['' + slll.slot][ppp])
                                    });
                                }
                            }

                            // const randomStaff = getRandomNumber(slotWise.appliedStaff.length, howMuchWin);
                        } else if (slll.opsGroupQuotaValue >= slll.totalTeamQuota) {
                            // all team quota should win
                            slll.opsTeamQuotaValue.forEach((p, opsTeamQuotaValueIndex) => {

                                if (appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex] && appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot]) {
                                    //console.logs('bbb');
                                    const len = appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot].length;
                                    //console.logs('len', len, slll.slot, p);
                                    // p means no of win
                                    // len means no of applied
                                    if (len > p) {
                                        const randomStaff = getRandomNumber(len, p);
                                        //console.logs('randomStaff', randomStaff);
                                        randomStaff.forEach((randomSelectedStaff) => {
                                            finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot][randomSelectedStaff])
                                        });
                                    } else {
                                        for (let x = 0; x < len; x++) {
                                            finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot][x]);
                                        }
                                    }

                                }
                                //const randomStaff = getRandomNumber(slotWise.appliedStaff.length, howMuchWin);
                            });


                        } else { // if ops group quota value is less then total team quota
                            let allAppliedStaff = [];
                            slll.opsTeamQuotaValue.forEach((p, opsTeamQuotaValueIndex) => {
                                ////console.logs('topIndexppppppp', topIndex, opsTeamQuotaValueIndex);
                                if (appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex] && appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot]) {
                                    //console.logs('aaaaeee');
                                    if (p >= appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot].length) {
                                        // //console.logs('hh', appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex][''+slll.slot])
                                        allAppliedStaff = allAppliedStaff.concat(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot])
                                    } else {
                                        //console.logs('thiselseworkssss')
                                        const randomStaff = getRandomNumber(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot].length, p);
                                        randomStaff.forEach((ppp) => {
                                            allAppliedStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex]['' + slll.slot][ppp])
                                        });
                                    }
                                    /*       //console.logs('bbb');
                                    const len = appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex][''+slll.slot].length;
                                    //console.logs('len', len, slll.slot, p);
                                    // p means no of win
                                    // len means no of applied
                                    if(len>p) {
                                        const randomStaff = getRandomNumber(len, p);
                                        //console.logs('randomStaff', randomStaff);
                                        randomStaff.forEach((randomSelectedStaff)=>{
                                            finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex][''+slll.slot][randomSelectedStaff])
                                        });
                                    }else {
                                        for(let x=0; x<len; x++){
                                            finalWinStaff.push(appliedStaffArray[topIndex].opsTeamValue[opsTeamQuotaValueIndex][''+slll.slot][x]);
                                        }
                                    }*/
                                }


                                //const randomStaff = getRandomNumber(slotWise.appliedStaff.length, howMuchWin);
                            });
                            if (allAppliedStaff.length > 0) {
                                //console.logs('ahugwgg')
                                const finalAppliedStaff = [];
                                const randomStaff = getRandomNumber(allAppliedStaff.length, allAppliedStaff.length);
                                //console.logs('randomStaff', randomStaff, allAppliedStaff.length);
                                randomStaff.forEach((ppp) => {
                                    finalAppliedStaff.push(allAppliedStaff[ppp])
                                });
                                const finalRandomStaff = getRandomNumber(allAppliedStaff.length, slll.opsGroupQuotaValue);
                                //console.logs('finalRandomStaff', finalRandomStaff)
                                //console.logs('sdhfys', allAppliedStaff.length, finalRandomStaff, slll.opsGroupQuotaValue);
                                finalRandomStaff.forEach((ppp) => {
                                    finalWinStaff.push(finalAppliedStaff[ppp])
                                });
                            }
                        }
                    });
                });

                const updateWin = await Ballot.findOneAndUpdate({_id: ballotId}, {

                    $set: {
                        wonStaff: finalWinStaff,
                        isConduct: true,
                        isResultRelease: false
                    }
                })
                unSuccessfullStaffLeaveBallotBalanaceUpdate(ballotId);
            }
        } else {

        }


    } catch (e) {
        //console.logs('ee', e);
    }
}

function getRandomNumber(length, howMany) {
    //console.logs("aaaaa")
    if (howMany > length) {
        howMany = length;
    }
    const arr = [];
    for (let i = 0; i < howMany; i++) {
        const num = Math.floor(Math.random() * (length - 0)) + 0;
        if (arr.includes(num)) {
            i = i - 1;
        } else {
            arr.push(num);
        }

    }
    return arr;
}

async function unSuccessfullStaffLeaveBallotBalanaceUpdate(ballotId) {
    //console.logs('ballotId', ballotId)
    const ballotData = await Ballot.findOne({_id: ballotId});
    let leave = 5;
    if (ballotData.leaveConfiguration === 2) {
        leave = 6;
    } else if (ballotData.leaveConfiguration === 3) {
        leave = 7;
    }
    const appliedStaff = groupBy(ballotData.appliedStaff, 'userId');
    const wonStaff = groupBy(ballotData.wonStaff, 'userId');
    ////console.logs('ba', JSON.stringify(ballotData));
    const updateLeaveBy = [];
    for (let key in appliedStaff) {
        const obj = {
            userId: key,
            value: 0
        };
        const staffAppliedCount = appliedStaff[key].length;
        let staffWonCount = 0;
        if (wonStaff[key]) {
            staffWonCount = wonStaff[key].length;
        }
        obj.value = (staffAppliedCount - staffWonCount) * leave;
        updateLeaveBy.push(obj);
    }
    for (let i = 0; i < updateLeaveBy.length; i++) {
        const user = updateLeaveBy[i];
        //console.logs('user', user)
        if (user.value > 0) {
            const staffLevae = await StaffSapData.findOne({staff_Id: user.userId});
            if (staffLevae) {
                let totalLeave = staffLevae.ballotLeaveBalanced + user.value;
                if (totalLeave > staffLevae.leavesBalanced) {
                    totalLeave = staffLevae.leavesBalanced;
                }
                // //console.logs(staffLevae)
                const update = await StaffSapData.update({staff_Id: user.userId}, {$set: {ballotLeaveBalanced: totalLeave}});
            }
        }
    }

    function groupBy(xs, key) {
        return xs.reduce(function (rv, x) {
            (rv[x[key]] = rv[x[key]] || []).push(x);
            return rv;
        }, {});
    };
}

async function ballotNotificationOnLastDay() {
    //console.logs('caleesdfddgfdd');
    //console.logs('after 1 hr');
    const currentTime = new Date();
    //console.logs(currentTime)
    currentTime.setHours(0, 0, 0, 0);
    console.log('currentTime', currentTime);
    const beforeTime = moment(currentTime).add(1, 'd').toDate();
    const afterTime = moment(currentTime).add(2, 'd').toDate();
    //console.logs('beforeTime', beforeTime);
    //console.logs('afterTime', afterTime);
    const ballotList = await Ballot.find({
        isDeleted: false, isCanceled: false, isNotified: 2,isDraft: false,
        applicationCloseDateTime: {
            $lte: new Date(beforeTime).toISOString()
        }

    });
    // const ballotList = await Ballot.find({_id:"5d74ca847c90200d4bbd6b5a"});


    ////console.logs('ballot', ballotList);
    if (ballotList.length > 0) {
        ////console.logs('found', JSON.stringify(ballotList));
        for (let i = 0; i < ballotList.length; i++) {
            const item = ballotList[i];
            // get user
            // update ballot ispublish

            if (item.userFrom === 1) {
                // user from ops group
                const userIDArr = await OpsGroup.find({_id: {$in: item.opsGroupId}, isDelete: false}, {
                    userId: 1,
                    _id: 0
                });
                let userId = [];
                userIDArr.forEach((item) => {
                    userId = userId.concat(item.userId)
                });
                //console.logs('userId', userId)
                const unAssignUser = await User.find({_id: {$in: userId}})
                    .select("deviceToken")
                    .lean();
                ////console.logs('user11', JSON.stringify(unAssignUser));
                const usersDeviceTokens = [];
                unAssignUser.forEach((token) => {
                    if (token.deviceToken) {
                        usersDeviceTokens.push(token.deviceToken)
                    }
                });
                //console.logs('usersDeviceTokens', usersDeviceTokens);
                var appLastDate = new Date(item.applicationCloseDateTime);
                let appLastDateHere = appLastDate.toISOString().slice(0,10)
                if (usersDeviceTokens.length > 0) {
                    const pushData = {
                            title: 'Reminder on the Balloting Exercise',
                            body: 'Today is the Ballot Exercise '+item.ballotName+' closing day '+appLastDateHere+'if not balloted yet, ballot before it closes.',
                            bodyText: 'Today is the Ballot Exercise '+item.ballotName+' closing day '+appLastDateHere+'if not balloted yet, ballot before it closes.',
                            bodyTime: [item.applicationCloseDateTime, item.applicationCloseDateTime],
                            bodyTimeFormat: ['DD-MMM-YYYY', 'HH:mm']
                        },
                        collapseKey = item._id; /*unique id for this particular ballot */
                    FCM.push(usersDeviceTokens, pushData, collapseKey);
                }
                const data = await Ballot.update({_id: item._id}, {isNotified: 3})
            } else {
                var appLastDate = new Date(item.applicationCloseDateTime);
                let appLastDateHere = appLastDate.toISOString().slice(0,10)
                // user from bu
                const userList = await User.find({parentBussinessUnitId: {$in: item.businessUnitId}}, {
                    _id: 0,
                    deviceToken: 1
                });
                const usersDeviceTokens = [];
                userList.forEach((token) => {
                    if (token.deviceToken) {
                        usersDeviceTokens.push(token.deviceToken)
                    }
                });
                if (usersDeviceTokens.length > 0) {
                    const pushData = {
                            title: 'Reminder on the Balloting Exercise',
                            body: 'Today is the Ballot Exercise '+item.ballotName+' closing day '+appLastDateHere+'if not balloted yet, ballot before it closes.',
                            bodyText: 'Just 1 day left for close of this Ballot submission. Ballot Name: ' + item.ballotName + 'ballot before it closes.',
                            bodyTime: [item.applicationCloseDateTime],
                            bodyTimeFormat: ['DD-MMM-YYYY HH:mm']
                        },
                        collapseKey = item._id; /*unique id for this particular ballot */
                    FCM.push(usersDeviceTokens, pushData, collapseKey);
                }
                const data = await Ballot.update({_id: item._id}, {isNotified: 3})
            }
        }
    } else {
        //console.logs('ndsssddost found')
    }
}

setInterval(async () => {
    // conduct ballot
    //console.logs('after 511 sec');
    const currentTime = new Date();
    //console.logs('currentTime', currentTime)
    const beforeTime = moment(currentTime).add(-15, 'm').toDate();
    const afterTime = moment(currentTime).add(16, 'm').toDate();
    //console.logs('beforeTime', beforeTime);
    //console.logs('afterTime', afterTime)
    const ballotList = await Ballot.find({
        isDeleted: false, isCanceled: false, isDraft: false, isConduct: false, isAutoAssign: false,
        applicationCloseDateTime: {
            $lte: new Date(beforeTime).toISOString()
        }

    });
    // const ballotList = await Ballot.find({_id:"5d74ca847c90200d4bbd6b5a"});


   
    if (ballotList.length > 0) {
        // //console.logs('found', JSON.stringify(ballotList));
        for (let i = 0; i < ballotList.length; i++) {
            //console.logs('Ashish Found');
            //console.logs('ballotList[i]._id', ballotList[i]._id);
            await conductBallot(ballotList[i]._id);
        }
    } else {
        //console.logs('ndsssddost found')
    }
}, 6000);
// sss
new CronJob({
    cronTime: '00 00 10 * * * ',
    onTick: function () {
        console.log('yuup')
        ballotNotificationBefore2Days();
        ballotNotificationBefore1Day();
        ballotNotificationOnLastDay();
        //Your code that is to be executed on every midnight
    },
    start: true,
    runOnInit: false
});
ballot = new ballot();
module.exports = ballot;
